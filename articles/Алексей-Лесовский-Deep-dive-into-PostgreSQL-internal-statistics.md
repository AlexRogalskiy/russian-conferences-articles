**Deep dive into PostgreSQL internal statistics / Алексей Лесовский**

Расшифровка доклада 2015 года Алексея Лесовского "Deep dive into PostgreSQL internal statistics"

Часть поста устарела, но здесь рассмотрена фундаментальная статистика PostgreSQL, которая актуальна и сейчас.

![](https://habrastorage.org/webt/8d/zi/wq/8dziwqqvzrr6n_jpe0vb1djgf4q.png)

Добрый день! Меня зовут Алексей. Как Илья сказал, я буду рассказывать про статистику PostgreSQL.

![](https://habrastorage.org/webt/44/hq/rw/44hqrwbe_ilywzjen1phivicteu.png)

Статистика активности PostgreSQL. У PostgreSQL есть две статистики. Статистика активности, про которую будет речь. И статистика планировщика о распределении данных. Я буду рассказывать именно о статистике активности PostgreSQL, которая позволяет нам судить о производительности и как-то ее улучшать.

Расскажу, как эффективно использовать статистику для решения самых разных проблем, которые у вас возникают или могут возникнуть. 

![](https://habrastorage.org/webt/qf/-w/uv/qf-wuvngd11nlszoh84ak7ixln4.png)

Чего не будет в докладе? В докладе не будет статистики планировщика. Т. е. это очень большой пласт на отдельный доклад о том, как данные хранятся в базе, как идет распределение этих данных. 

И не будет обзоров инструментов. Т. е. я не буду сравнивать один продукт с другим. Никакой рекламы не будет. Отбросим это. 

![](https://habrastorage.org/webt/qz/xm/lu/qzxmlucpbq8h16yh-owxuod1lb4.png)

Я хочу вам показать, что использовать статистику – это полезно. Это нужно. Использовать ее нестрашно. Нам понадобится всего лишь обычный SQL, базовые знания SQL.

И поговорим, какую статистику выбирать для решения проблем.

![](https://habrastorage.org/webt/l6/lx/ug/l6lxug6s9ojmchwkfhzipuahhxw.png)

Если мы посмотрим на PostgreSQL и в операционной системе запустим команду для просмотра процессов, то увидим черный ящик. Мы увидим какие-то процессы, которые что-то делают, и мы по названию можем примерно представить, что они там делают, чем занимаются. Но, по сути, это черный ящик, вовнутрь мы заглянуть не можем. 

Мы можем посмотреть нагрузку на процессор в `top`, можем посмотреть утилизацию памяти какими-то системными утилитами, но заглянуть вовнутрь PostgreSQL мы не сможем. Для этого нам нужны другие инструменты. 

![](https://habrastorage.org/webt/do/bl/uo/dobluoy4uh1mqt9lzq5gewnquom.png)

И продолжая дальше я расскажу, куда тратится время. Если мы представим PostgreSQL в виде такой схемы, то можно будет ответить, куда тратится время. Это две вещи: это обработка клиентских запросов от приложений и фоновые задачи, которые выполняет PostgreSQL для поддержания своей работоспособности.

Если мы начнем рассматривать с правого верхнего угла, то мы можем проследить, как обрабатывается клиентские запросы. Запрос приходит от приложения. К нему открывается сессия. Запрос передается в планировщик. Планировщик строит план запроса. Отправляет его дальше на выполнение. Происходит какой-то ввод-вывод данных таблиц, индексов. Все это поднимается в shared buffers. Результаты запроса, если это updates, deletes, фиксируются в журнале транзакций в WAL. Потом значения какие-то попадают в логер, либо попадают в статистику. И результат запроса отдается уже клиенту обратно вверх по stack.

Что у нас с фоновыми задачами и с фоновыми процессами? У нас есть несколько процессов, которые обеспечивают работоспособность и поддерживают базу данных в нормальном рабочем режиме. Про эти процессы я буду говорить: это autovacuum, checkpointer, процессы, связанные с репликацией, background writer и checkpointer process. Я буду их всех затрагивать по мере доклада.

![](https://habrastorage.org/webt/_6/zp/8a/_6zp8aiksnauyjpuy1emyyi7ipe.png)

Какие проблемы есть со статистикой? 

- Информации много. PostgreSQL 9.4 предоставляет 109 метрик для просмотра данных статистики. Однако, если в базе данных хранятся много таблиц, схем, баз, то все эти метрики придется умножить на соответствующее количество таблиц, баз. Т. е. информации становится еще больше. И утонуть в ней очень легко.

- Следующая проблема – это то, что статистика представлена онлайн-счетчиками. Если мы посмотрим эту статистику, то мы увидим постоянно увеличивающиеся счетчики. И если с момента сброса статистики прошло очень много времени, мы увидим миллиардные значения. И они нам ничего не говорят.  

- Нет истории. Если у вас произошел какой-то факап, что-то у вас упало 15-30 минут назад, вы не сможете воспользоваться статистикой и посмотреть, что происходило 15-30 минут назад. Это проблема.

- Отсутствие нативного (встроеного в PostgreSQL) инструмента – это проблема. Разработчики ядра не предоставляют никакой утилиты. У них нет ничего такого. Они просто дают статистику в базе. Пользуйтесь, делайте к ней запрос, что хотите, то и делайте.  

- Нативного (встроеного в PostgreSQL) инструмента нет и это является следствием другой проблемы. Множество сторонних инструментов. Каждая компания, у которой есть более-менее прямые руки, пытается написать свою программу. И в итоге в community очень много инструментов, которыми можно пользоваться для работы со статистикой. И в одних инструментах есть одни возможности, в других инструментах нет других возможностей, либо есть какие-то новые возможности. И возникает ситуация, что нужно использовать два-три-четыре инструмента, которые друг друга перекрывают и обладают разными функциями. Это очень неприятно.  

![](https://habrastorage.org/webt/ii/gj/en/iigjenmvagagz2pgncnxdofdqls.png)

Что из этого следует? Важно уметь брать статистику напрямую, чтобы не зависеть от программ, либо как-то самому улучшить эти программы: добавить какие-то функции, чтобы получить свою выгоду. 

И нужны базовые знания SQL. Чтобы получить какие-то данные из статистики, нужно составить запросы SQL, т. е. вам нужно знать, как составляются select, join.

![](https://habrastorage.org/webt/82/jz/me/82jzmew2kjrmmvx5xagkhkuawwc.png)

 Статистика предлагает нам несколько вещей. Их можно разделить на категории.

- Первая категория – это события, происходящие в базе. Когда в базе происходит какое-то событие: запрос, обращение к таблице, автовакуум, коммиты, то это все события. Соответствующие счетчики инкрементируются. И мы можем отследить эти события.  

- Вторая категория – это свойства объектов такие, как таблицы, базы. У них есть свойства. Это размер таблиц. Мы можем отследить рост таблиц, рост индексов. Можем посмотреть изменения в динамике.  

- И третья категория – это время, затраченное на событие. Запрос – это событие. У него есть своя конкретная мера длительности. Здесь запустился, тут закончился. Мы можем это отследить. Либо время чтения блока с диска или записи. Такие вещи тоже отслеживаются.  

![](https://habrastorage.org/webt/_0/mh/a_/_0mha_byhkpbr8ias2qjfyf5wkk.png)

Источники статистики представлены следующим образом: 

- В шаредной памяти (shared buffers) блок памяти, который отдан PostgreSQL для размещения там данных, там есть счетчики, которые постоянно инкрементируются, когда происходит те или иные события, либо возникают какие-то моменты в работе базы.  

- Все эти счетчики не доступны пользователю, не доступны администратору. Это низкоуровневые вещи. Чтобы к ним обратиться PostgreSQL предоставляет функции. Мы можем выбрать select функция и получить какую-то метрику.  

- Однако использовать эти функции не всегда удобно, поэтому функции представлены в виде представлений (VIEWs). Это виртуальные таблицы, которые предоставляют статистику по какой-то конкретной подсистеме, либо по какому-то набору событий в базе данных.  

- И есть встроенные представления (VIEWs). Вы PostgreSQL запустили и можете сразу ими пользоваться, смотреть, брать оттуда информацию. И есть contrib'ы. Contrib'ы есть официальные. Вы postgresql-contrib (например, postgresql94-contrib) установили, подгрузили его в конфигурации, указали для него параметры, перезапустили PostgreSQL и можете пользоваться.

- И есть неофициальные contrib. Они не поставляются в стандартной поставке PostgreSQL. Их нужно либо скомпилировать, либо подсунуть библиотеку. Варианты могут быть самые разные, в зависимости от того, что придумал разработчик этого неофициального contrib’а.  

![](https://habrastorage.org/webt/oq/cb/cl/oqcbclvrz_chxnihgvcsvo7nwhm.png)

Я вам показываю все те представления (VIEWs) и часть тех функций, которые доступны. Как мы видим, их очень много. И довольно легко запутаться, если вы столкнулись с этим в первый раз.

![](https://habrastorage.org/webt/ik/fx/ol/ikfxol834oxvxqm3rhnsvpdu99g.png)

Однако, если мы возьмем предыдущую картинку `Как тратится время на PostgreSQL` и совместим с этим списком, то получим вот такую статистику. Каждое представление (VIEWs), либо каждую функцию мы можем использовать в тех или иных целях для получения соответствующей статистики, когда у нас работает PostgreSQL. И можем получить уже какую-то информацию о работе подсистемы. 

![](https://habrastorage.org/webt/rz/j_/wf/rzj_wfer1eswag9lntqr15ykwlw.png)

Первое, что мы рассмотрим, это pg_stat_database. Как мы видим, это представление (VIEWs). В ней очень много информации. Т. е. самая разнообразная информация. И она дает очень полезное знание, что у нас происходит в базе данных. 

Что мы можем полезное оттуда взять? Начнем c самых простых вещей.

![](https://habrastorage.org/webt/in/1l/6w/in1l6wbqytyjnnkpyrqtr2q18km.png)

```sql
select
sum(blks_hit)*100/sum(blks_hit+blks_read) as hit_ratio
from pg_stat_database;
```

Первое, что мы можем посмотреть – это процент попадания в кэш. Процент попадания в кэш – это полезная метрика. Она позволяет оценить, насколько у нас данные берутся из кэша из операционной памяти, либо они берутся с диска. 

Понятное дело, что **чем большее у нас попадание в кэш, то тем лучше**. Мы оценивает эту метрику как процент. И, соответственно, если у нас процентное отношение этих попаданий в кэш больше 90 %, то это хорошо. **Если оно опускается ниже 90 %, значит, у нас памяти недостаточно для удержания горячей головы о данных в памяти. И чтобы эти данные как-то подтянуть PostgreSQL вынужден обращаться к диску и это замедляет работу. И нужно уже думать над увеличением памяти: либо shared buffers увеличивать, либо наращивать железную память.** 

![](https://habrastorage.org/webt/gt/7d/yl/gt7dylzytgbq5db0zkb3v13tbf4.png)

```sql
select
datname,
(xact_commit*100)/(xact_commit+xact_rollback) as c_ratio,
deadlocks, conflicts,
temp_file, pg_size_pretty(temp_bytes) as temp_size
from pg_stat_database;
```



Что можно еще взять из этого представления (VIEWs)? Можно посмотреть там аномалии, происходящие в базе. Что здесь показано? Здесь есть commits, rollbacks, создание временных файлов, их объем, deadlocks и конфликты. 

Мы можем воспользоваться этим запросом. Это SQL довольно простой. И можем посмотреть вот эти данные у себя.

![](https://habrastorage.org/webt/8v/3m/44/8v3m449d61nxacbamybuxlo0n8e.png)

И вот сразу пороговое значение. Мы смотрим соотношение commits и rollbacks. Commits – это успешное подтверждение транзакции. Rollbacks – это откат, т. е. транзакция делала какую-то работу, напрягала базу, что-то считала, а потом произошел сбой, и результаты транзакции отбрасываются. Т. е. **количество rollbacks, постоянно увеличивающихся, это плохо. И следует как-то избегать их, и править код, чтобы такого не происходило.** 

**Конфликты (conflicts) связаны с репликацией. И их тоже следует избегать.** Если у вас какие-то запросы, которые выполняются на реплике и возникают конфликты, то нужно эти конфликты разбирать, смотреть, что происходит. Это обычно делается в логах. И устранять конфликтные ситуации, чтобы ошибок приложению не возвращалось. 

**Deadlocks – это тоже плохая ситуация. Там, когда запросы борются за ресурсы, один запрос обратился, второй запрос обратился к одному ресурсу, и они друг друга заблокировали. Это тоже проблемная ситуация. Их нужно решать на уровне переписывания приложений.** И если вы видите, что у вас deadlocks увеличиваются постоянно, нужно разбирать кейсы и смотреть в чем проблема. 

**Временные файлы (temp_files) – это тоже плохо. Когда postgres’овому connect’у не хватает памяти для оперативных временных данных, он создает на диске файл. И начинает все операции выполнять уже на диске. Это медленно.** Это замедляет работу postgres’ового connect’а. И клиент, подключившийся к PostgreSQL получит более долгий ответ. Если эти все операции будут выполняться в памяти, он ответ получит гораздо быстрее, клиенту нужно будет меньше ждать. 

![](https://habrastorage.org/webt/qs/kt/u3/qsktu3tnn6wgc2ga7okewnud3w8.png)

Pg_stat_bgwriter – это представление описывает работу двух фоновых подсистем PostgreSQL: это checkpoints и фоновый писатель. 

![](https://habrastorage.org/webt/1q/hu/wa/1qhuwacn-vc5k8imyd-iftle7ii.png)

Для начала разберем checkpoints. Что такой checkpoints? Checkpoint – это сброс грязных страниц в шаредной памяти (shared buffers) на диск. Для чего это нужно? Если бы PostgreSQL все время обращался к диску и брал оттуда данные, и записывал данные при каждом обращении, это было бы медленно. Поэтому у PostgreSQL есть большой объем памяти, так же это зависит от выставленных параметров в конфигурации. Он эту область использует для помещения туда данных. Потом как-то их меняет. И мы получаем две версии данных. Одна у нас в памяти, другая на диске. И периодически нам нужно эти данные синхронизировать. Нам нужно то, что изменено в памяти, синхронизировать на диск. Для этого нужны checkpoint.

Checkpoint проходит по shared buffers, помечает грязные страницы, что они нужны для checkpoint. Потом запускает второй проход по shared buffers. И страницы, которые помечены для checkpoint, он их уже синхронизирует. Таким образом выполняется синхронизация данных уже с диском. 

И checkpoint есть два. Один checkpoint выполняется по тайм-ауту. Это checkpoint полезный – checkpoint_timed. И есть checkpoints по принуждению – checkpoint required. Это когда у нас идет очень большая запись данных. Мы записали очень много журналов транзакций. И PostgreSQL считает, что ему нужно все это как можно быстрее синхронизировать, сделать контрольную точку и жить дальше. 

И если вы посмотрели статистику pgwriter и увидели, что у вас **checkpoint required гораздо больше, чем timed, то это плохо. Почему плохо? Это значит, что PostgreSQL находится в постоянной стрессовой ситуации, когда ему нужно записывать данные.** Checkpoint timed растянут по времени. У PostgreSQL есть возможность сделать паузы в работе и не напрягать дисковую подсистему. Это для PostgreSQL полезно. И запросы, которые выполняются во время checkpoint не будут испытывать стрессы от того, что дисковая подсистема занята. 

И для регулировки checkpoint есть три параметра:

- Checkpoint_segments.

- Checkpoint_timeout.

- Checkpoint_competion_target.  

Они позволяют регулировать работу checkpoint. Не буду на них задерживаться. Их влияние – это уже другая тема.

![](https://habrastorage.org/webt/h0/ox/tu/h0oxtusf16s0rvlikpg1ath0muu.png)

Следующая подсистема – это background writer. Что он делает? Он работает постоянно в бесконечном цикле. Сканирует шаредную память (shared buffers) и странички грязные, которые он нашел, сбрасывает на диск. Т. е. он помогает checkpoint делать меньше работы. 

Для чего он еще нужен? Он обеспечивает бэкенды чистыми страницами. Когда клиентское подключение запросило новые данные, у него есть чистые страницы. Ему не надо самому ничего чистить, он берет эти страницы и пользуется. **Если вы видите, что у вас параметр `maxwritten_clean` большой, это значит, что background writer не справляется со своей работой и нужно увеличивать параметры `bgwriter_lru_maxpages`**, чтобы он смог за один цикл сделать больше работы, больше очистить страничек. 

**И другой очень вредный показатель – это `buffers_backend_fsync`.** Бэкенды не делают fsync, потому что это медленно. Они передают fsync выше по stack checkpointer’у. У checkpointer есть своя очередь, он периодически fsync обрабатывает и файлы синхронизирует. **Если очередь большая у checkpointer и заполнена, то бэкенд вынужден сам делать fsync и это замедляет работу бэкенда**, т. е. клиент получит ответ позже, чем мог бы. Если вы видите, что у вас это значение больше нуля, то это уже больше и **нужно оптимизировать дисковую подсистему.** 

![](https://habrastorage.org/webt/pc/4m/j6/pc4mj62p-kbr3bljysintew2su8.png)

Тут тоже у нас много параметров. Но понадобятся нам всего лишь пункты, связанные с location. 

![](https://habrastorage.org/webt/ep/xk/mo/epxkmodndt65xosqkutjikocc8i.png)

**Если мы видим, что все значения равны, то это идеальный вариант и у нас реплика не отстает от мастера.**

Вот эта шестнадцатеричная позиция – это позиция в журнале транзакций. Она постоянно увеличивается, если в базе есть какая-то активность: inserts, deletes и т. д. 

![](https://habrastorage.org/webt/ef/zk/ec/efzkecianqamsvw4jtqeqa59luk.png)

```sql
сколько записано xlog в байтах
$ select
pg_xlog_location_diff(pg_current_xlog_location(),'0/00000000');
лаг репликации в байтах
$ select
client_addr,
pg_xlog_location_diff(pg_current_xlog_location(), replay_location)
from pg_stat_replication;
лаг репликации в секундах
$ select
extract(epoch from now() - pg_last_xact_replay_timestamp());
```

Если эти вещи отличаются, значит есть какой-то лаг. Лаг – это отставание мастера от реплики, т. е. данные отличаются между серверами.

Есть три причины отставания: 

- Это дисковая подсистема не справляется с записью синхронизации файлов.  

- Это возможные ошибки сети, либо перегрузка сети, когда данные не успевают доезжать до реплики и он не может их воспроизвести.  

- И процессор. Процессор – это очень редкий случай. И я видел такое два или три раза, но такое тоже может быть.

И вот три запроса, которые нам позволяют использовать статистику. Мы можем оценить, сколько записано у нас в журнале транзакции. Есть такая функция `pg_xlog_location_diff` и можем оценить лаг репликации в байтах и секундах. Мы тоже для этого используем значение из этого представления (VIEWs). 

С лагом, который в секундах, есть один момент. Если на мастере не происходит никакой активности, транзакция там была где-то 15 минут назад и активности никакой нет, и если мы на реплике посмотрим этот лаг, то мы увидим лаг в 15 секунд. Об этом стоит помнить. И это может вводить в ступор, когда вы посмотрели этот лаг. 

![](https://habrastorage.org/webt/oy/fx/vp/oyfxvpxmsnjwqp8ugdma9ezxtl4.png)

Pg_stat_all_tables – это полезное представление (VIEWs). Оно показывает статистику по таблицам. Когда у нас в базе есть таблицы, с ним есть какая-то активность, какие-то действия, мы можем эту информацию получить из этим представлением (VIEWs).

![](https://habrastorage.org/webt/t2/o2/vc/t2o2vcdij14qo4yqpkukhwmrpne.png)

```sql
select
relname,
pg_size_pretty(pg_relation_size(relname::regclass)) as size,
seq_scan, seq_tup_read,
seq_scan / seq_tup_read as seq_tup_avg
from pg_stat_user_tables
where seq_tup_read > 0 order by 3,4 desc limit 5;
```

Первое, что мы можем посмотреть, это последовательные проходы, последовательное сканирование по таблице. Само число после этих проходов еще не обязательно плохо и не показатель того, что нам нужно уже что-то там делать.

**Однако есть вторая метрика – seq_tup_read. Это количество строк, возвращенных в результате последнего сканирования. Если усредненное число превышает 1 000, 10 000, 50 000, 100 000, то это уже показатель, что возможно вам нужно где-то построить индекс, чтобы обращения были по индексу, либо оптимизировать запросы, чтобы такого не было.** 

Простой пример – это, допустим, offset с большим количеством и лимит стоит. Т. е. мы сканируем 100 000 строк в таблице и после этого берем 50 000 строк. Это тоже плохой кейс. И такие запросы нужно оптимизировать. И здесь вот такой простой SQL-запрос, на котором можно это посмотреть и оценить примерные цифры. 

![](https://habrastorage.org/webt/xg/ub/jq/xgubjqtjchxsguekyvlkuh-vssu.png)

```sql
select
relname,
pg_size_pretty(pg_total_relation_size(relname::regclass)) as
full_size,
pg_size_pretty(pg_relation_size(relname::regclass)) as
table_size,
pg_size_pretty(pg_total_relation_size(relname::regclass) -
pg_relation_size(relname::regclass)) as index_size
from pg_stat_user_tables
order by pg_total_relation_size(relname::regclass) desc limit 10;
```



Размеры таблиц также можно получить с помощью этой таблицы и с помощью дополнительных функций `pg_total_relation_size`, `pg_relation_size`.

Есть метакоманды `\dt` и `\di`, которые можно выпустить в PSQL и посмотреть размеры. 

Однако использование функций помогает нам посмотреть размеры таблиц еще с учетом индексов, либо без учетов индексов и уже делать какие-то оценки на основе роста базы данных, т. е. как она у нас растет, с какой интенсивностью и делать уже какие-то выводы об оптимизации размеров. 

![](https://habrastorage.org/webt/aj/hh/a8/ajhha8wpkijuymwhqvbq7wzkgxy.png)

Активность на запись. Что такое запись? Запись (я написал update) – это операция обновления в таблице. По сути, update – это две операции. Это вставка новой версии строки и пометка старой версии строки как неиспользуемая. В последствии придет автовакуум и вот эти неиспользуемые строки вычистит, пометит это место как доступное для повторного использования.

Кроме того, update – это не только обновление таблицы. Это еще обновление индексов. Если у вас на таблице много индексов, то при update все индексы, в которых участвуют поля, обновляемые в запросе, нужно будет перестроить. В этих индексах также будут мертвые строки, которые нужно будет почистить. 

![](https://habrastorage.org/webt/so/wq/dq/sowqdqlnksjvoq5t3s7qa43rmtm.png)

```sql
select
s.relname,
pg_size_pretty(pg_relation_size(relid)),
coalesce(n_tup_ins,0) + 2 * coalesce(n_tup_upd,0) -
coalesce(n_tup_hot_upd,0) + coalesce(n_tup_del,0) AS total_writes,
(coalesce(n_tup_hot_upd,0)::float * 100 / (case when n_tup_upd > 0
then n_tup_upd else 1 end)::float)::numeric(10,2) AS hot_rate,
(select v[1] FROM regexp_matches(reloptions::text,E'fillfactor=(\\d+)') as
r(v) limit 1) AS fillfactor
from pg_stat_all_tables s
join pg_class c ON c.oid=relid
order by total_writes desc limit 50;
```



И update – это тяжеловесные операции. Но их можно облегчить. Есть hot updates. Они появились в PostgreSQL версии 8.3. И что это такое? Это легковесный update, который не вызывает перестроение индексов. Т. е. мы обновили запись, но при этом обновилась только запись в страничке, а индексы по-прежнему указывают на ту же самую запись в странице. Там немного такая интересная логика работы, когда приходит вакуум, то он эти цепочки hot перестраивает и все продолжает работать без обновления индексов, и происходит все легковесно. Т. е. мы делаем легковесные обновления. 

**И когда у вас `n_tup_hot_upd` большое, то это очень хорошо. Это значит, что легковесные updates проходят гораздо легче для таблиц и все прекрасно.** 

![](https://habrastorage.org/webt/nu/fw/wg/nufwwgowva_voi5_tixn3diibac.png)

```sql
ALTER TABLE table_name SET (fillfactor = 70);
```

Как увеличить объем hot обновляемых таблиц? Мы можем использовать fillfactor. Он определяет размер заполнения страницы в таблице. Когда в таблицу идут inserts, то они полностью заполняют страничку, не оставляют в ней пустого места. Потом выделяется новая страничка. Снова данные заполняются. И это поведение по умолчанию, fillfactor = 100 %.

**Мы можем сделать fillfactor в 70 %. Т. е. при inserts выделилась новая страничка, но заполнилось всего лишь 70 % странички. И 30 % у нас осталось на резерв. Когда нужно будет сделать update, то он с высокой долей вероятности произойдет в той же самой страничке, и новая версия строки поместится в ту же страничку. И будет сделан hot_update. Таким образом облегчается запись на таблицах.** 

![](https://habrastorage.org/webt/2c/fd/3l/2cfd3lq4epuy3mbgqe_q1ixvxfq.png)

```sql
select c.relname,
current_setting('autovacuum_vacuum_threshold') as av_base_thresh,
current_setting('autovacuum_vacuum_scale_factor') as av_scale_factor,
(current_setting('autovacuum_vacuum_threshold')::int +
(current_setting('autovacuum_vacuum_scale_factor')::float * c.reltuples))
as av_thresh,
s.n_dead_tup
from pg_stat_user_tables s join pg_class c ON s.relname = c.relname
where s.n_dead_tup > (current_setting('autovacuum_vacuum_threshold')::int
+ (current_setting('autovacuum_vacuum_scale_factor')::float * c.reltuples));
```



Очередь автовакуума. Автовакуум – это такая подсистема, по которой статистике в PostgreSQL очень мало. Мы можем в таблицах только в pg_stat_activity увидеть, сколько у нас вакуумов длятся в данный момент. Однако понять, сколько таблиц в очереди у него с ходу очень сложно. 

Мы можем использовать вот такой упрощенный запрос. И можем посмотреть, когда должен будет сделан вакуум. Как триггерится вакуум? Вот эти мертвые строки, о которых я говорил раньше. Update произошел, новая версия строки вставилась. Появилась мертвая строка. В таблице `pg_stat_user_tables` есть такой параметр `n_dead_tup`. Он показывает количество мертвых строк. И как только количество мертвых строк стало больше, чем определенный порог, к таблице придет автовакуум. 

И как рассчитывается этот порог? Т. е. это процентное отношение от общего числа строк в таблице. Есть параметр `autovacuum_vacuum_scale_factor`. Он определяет процентное отношение. Допустим, 10 % + там есть базовый порог в 50 строк. И что получается? Когда у нас мертвых строк стало больше 10 % от таблицы, то мы ставим таблицу на автовауум.

![](https://habrastorage.org/webt/6p/gn/ox/6pgnox0d7bwmwzhsbnjcam2rzse.png)

```sql
select c.relname,
current_setting('autovacuum_vacuum_threshold') as av_base_thresh,
current_setting('autovacuum_vacuum_scale_factor') as av_scale_factor,
(current_setting('autovacuum_vacuum_threshold')::int +
(current_setting('autovacuum_vacuum_scale_factor')::float * c.reltuples))
as av_thresh,
s.n_dead_tup
from pg_stat_user_tables s join pg_class c ON s.relname = c.relname
where s.n_dead_tup > (current_setting('autovacuum_vacuum_threshold')::int
+ (current_setting('autovacuum_vacuum_scale_factor')::float * c.reltuples));
```

Однако тут есть один момент. Базовые пороги у параметров `av_base_thresh` и `av_scale_factor` могут назначаться индивидуально. И, соответственно, порог будет не глобальный, а индивидуальный для таблицы. Поэтому чтобы рассчитать, там нужно использовать ухищрения и уловки. И если вам интересно, то вы можете посмотреть на опыт наших коллег из Avito:

https://github.com/eshkinkot/avito/blob/master/munin/vacuum_queue

(Надо уточнить у Avito обновленную ссылку)

Они написали для munin plugin, которые учитывает эти вещи. Там портянка на два листа. Но считает он корректно и довольно эффективно позволяет оценить, где у нас вакуума много требуется для таблиц, где мало. 

Что мы можем с этим сделать? **Если у нас очередь большая, автовакуум не справляется, то мы можем поднять количество воркеров вакуума, либо просто сделать вакуум агрессивнее**, чтобы он триггерился раньше, обрабатывал таблицу маленькими кусочками. **И тем самым очередь будет уменьшаться.**

![](https://habrastorage.org/webt/9b/q1/1y/9bq11y4hodhskweeokqynhnj0jy.png)

Pg_stat_all_indexes – это статистика по индексам. Она небольшая. И мы можем по ней получить информацию по индексам сканирования. И можем определить какие индексы у нас лишние. 

![](https://habrastorage.org/webt/w-/83/w_/w-83w_gl41znzosfdvt_hcpmg5o.png)

Как я уже говорил, **update – это не только обновление таблиц, это еще обновление индексов.** Соответственно, если у нас на таблице много индексов и их нужно обновить, и **если у нас есть неиспользуемые индексы, по которым нет индексовых сканирований, то они у нас висят балластом. И от них нужно избавляться.** Для этого нам нужно поле `idx_scan`. Мы просто смотрим количество индексовых сканирований. Если у нас небольшой промежуток времени – ноль, то это плохие индексы, нам нужно от них избавиться. 

Две ссылки:

https://github.com/PostgreSQL-Consulting/pg-utils/blob/master/sql/low_used_indexes.sql

http://www.databasesoup.com/2014/05/new-finding-unused-indexes-query.html

Это примеры запросов для того, как искать неиспользуемые индексы. 

Вторая ссылка – это довольно интересный запрос. Там очень крутая логика заложена. Рекомендую его для ознакомления.

![](https://habrastorage.org/webt/yv/ch/i1/yvchi1pkvqluackjex8pchix_mw.png)

Что еще стоит подытожить? 

- Неиспользуемые индексы – это плохо.  

- Занимают место.  

- Замедляют операции обновления.

- Лишняя работа для вакуума.  

**Если мы удалим неиспользуемые индексы, то мы сделаем базе только лучше.** 

![](https://habrastorage.org/webt/xk/sb/v4/xksbv4c25g6qqfuer_gi5_hoeae.png)

Следующее представление (VIEWs) – это `pg_stat_activity`. Это аналог `ps`, только в PostgreSQL. Если `ps` ом вы смотрите процессы в операционной системе, то `pg_stat_activity` вам покажет бэкенды внутри PostgreSQL.

Что мы можем оттуда полезного взять?

![](https://habrastorage.org/webt/si/ew/kr/siewkr4grofcqg6k8bcq2jhil7g.png)

```
select
count(*)*100/(select current_setting('max_connections')::int)
from pg_stat_activity;
```

Мы можем посмотреть общую активность, что происходит в базе. Можем сделать новый деплой. У нас там все взорвалось, коннекты новые не принимаются, ошибки сыплются в приложении.

![](https://habrastorage.org/webt/ga/6t/2_/ga6t2_jk4mk95okroro5h0d5v-i.png)

```sql
select
client_addr, usename, datname, count(*)
from pg_stat_activity group by 1,2,3 order by 4 desc;
```



Мы можем выполнить вот такой запрос и посмотреть общий процент подключения, и посмотреть, кто у нас занимает больше всего коннектов. И в данном приведенном случае мы видим, что user `cron_role` открыл 508 коннектов. И что-то с ним там произошло. Нужно с ним разбираться и смотреть. И вполне возможно, что это какое-то аномальное число подключений.

![](https://habrastorage.org/webt/ci/dj/vk/cidjvkskcb3kmikplfwe8mkqe9y.png)

Если у нас нагрузка OLTP, запросы должны выполняться быстро, очень быстро и должно быть все хорошо. Однако, если возникают долгие запросы, то в краткосрочной перспективе ничего страшного нет, но **в долгосрочной перспективе долгие запросы вредят базе, они увеличивают bloat таблиц, когда у нас фрагментация таблиц увеличивается. И от bloat, и от вредных запросов нужно избавляться.**

![](https://habrastorage.org/webt/k1/rl/rg/k1rlrg5ilqkxduz9zksadf7hcro.png)

```sql
select
client_addr, usename, datname,
clock_timestamp() - xact_start as xact_age,
clock_timestamp() - query_start as query_age,
query
from pg_stat_activity order by xact_start, query_start;
```



Обратите внимание: вот таким запросом мы можем определять долгие транзакции. Мы используем функцию `clock_timestamp()` для определения времени работы. **Долгие запросы, которые мы нашли, мы можем их запомнить, выполнить `explain`, посмотреть планы и как-то оптимизировать.** Текущие долгие запросы мы отстреливаем и дальше живем. 

![](https://habrastorage.org/webt/ce/vh/nk/cevhnkgeddjls8lw6jclo9uzy5s.png)

```sql
select * from pg_stat_activity where state in
('idle in transaction', 'idle in transaction (aborted)';
```



**Плохие транзакции – это транзакции в состоянии idle in transaction и idle in transaction (aborted).**

Что это значит? Транзакции имеют несколько состояний. И одно из этих состояний могут принимать в любой момент времени. Для определения состояний есть поле «state» в этом представлении (VIEWs). И мы используем его для определения состояния. 

![](https://habrastorage.org/webt/db/aa/dy/dbaadywldmkgs4uz-sirvtiw_2c.png)

```sql
select * from pg_stat_activity where state in
('idle in transaction', 'idle in transaction (aborted)';
```

И, как я уже сказал выше, эти два состояния **idle in transaction и idle in transaction (aborted) – это плохо. Что это такое? Это когда код открыл транзакцию, сделал какие-то действия и ушел по своим делам. Транзакция осталась открытая. Она висит, они ничего не делает, она занимает коннект и потенциально еще увеличивает bloat других таблиц, потому что там есть накладные расходы на транзакционном движке. И такие транзакции тоже следует отстреливать, потому что они вредные в долгосрочной перспективе.** 

Если вы видите, что их у вас в базе больше 5-10-20, то нужно уже обеспокоиться и начинать с ними что-то делать.

Здесь мы также для времени вычисления используем clock_timestamp(). Транзакции отстреливаем, приложение оптимизируем.

![](https://habrastorage.org/webt/bv/lz/sq/bvlzsqnwiakymptboyi6valyhaq.png)

Как я уже говорил выше, блокировки – это когда две и больше транзакций борются за один или группу ресурсов. Для этого у нас есть поле `waiting` с боевым значением `true` и `false`.

**True – это значит, что процесс находится в ожидании, нужно что-то делать. Когда процесс находится в ожидании, значит, клиент, который инициировал этот процесс тоже ждет. Клиент в браузере сидит и тоже ждет.** 

![](https://habrastorage.org/webt/lj/lz/bf/ljlzbf8ayxhl3vfim4hyqpuknxq.png)

Что делать? **Если вы видите true, то значит, надо от них избавляться. Мы просто такие транзакции отстреливаем. Разработчикам пишем, что нужно как-то оптимизировать, чтобы не было гонки за ресурсами. И дальше разработчики оптимизируют приложение, чтобы такого не возникало.** 

И крайний случай – это **возникновение deadlocks. Две транзакции обновили два ресурса, потом обращаются к ним снова, уже к противоположным ресурсам. PostgreSQL в этом случае берет и сам отстреливает транзакцию, чтобы другая могла продолжить работу. Это тупиковая ситуация и она сама не разбирается. Поэтому PostgreSQL вынужден принимать крайние меры.**

![](https://habrastorage.org/webt/f2/ru/4e/f2ru4e6_4j3c_oi8qxyj9f1wziw.png)

https://github.com/lesovsky/uber-scripts/blob/master/postgresql/sql/c4_06_show_locked_queries.sql

https://github.com/lesovsky/uber-scripts/blob/master/postgresql/sql/show_locked_queries_95.sql

https://github.com/lesovsky/uber-scripts/blob/master/postgresql/sql/show_locked_queries_96.sql

http://big-elephants.com/2013-09/exploring-query-locks-in-postgres/

И вот два запроса, которые позволяют отслеживать блокировки. Мы используем представление (VIEWs) pg_locks, которая позволяет отслеживать эти тяжеловесные lock.

И первая ссылка – это сам текст запроса. Он довольно-таки длинный.

И вторая ссылка – это статья по locks. Ее полезно почитать, она очень интересная.

Итак, что мы видим? Мы видим два запроса. `Alter table` – это блокирующий ресурс. Он как раз у нас ушел из транзакции и где-то занимается своими делами. И второй запрос – update. Он ждет, когда закончится alter table, чтобы продолжить свою работу. 

Вот так мы можем выяснять, кто кого залочил, держит и можем разбираться с этим дальше. 

![](https://habrastorage.org/webt/uz/6j/bc/uz6jbcjaevda_vl63j5p9ai3j7s.png)

Следующий модуль – это pg_stat_statements. Как я уже сказал, это модуль. Чтобы им воспользоваться нужно подгрузить его в конфигурацию, перезапустить PostgreSQL и дальше у нас появится представление (VIEWs) для использования. 

![](https://habrastorage.org/webt/b7/0t/j5/b70tj5quyfxd6agwuwlam3dupwu.png)

```sql
Cреднее время запроса в милисекундах
$ select (sum(total_time) / sum(calls))::numeric(6,3)
from pg_stat_statements;

Самые активно пишущие (в shared_buffers) запросы
$ select query, shared_blks_dirtied
from pg_stat_statements
where shared_blks_dirtied > 0 order by 2 desc;
```



Что мы можем оттуда взять? Если говорить о простых вещах, мы можем взять среднее время выполнения запроса. Время растет, значит, у нас PostgreSQL отвечает медленно и нужно что-то делать.

Можем посмотреть самые активные пишущие транзакции в базе данных, которые меняют данные в shared buffers. Посмотреть, кто у нас там апдейтит, делитит. 

И можем просто посмотреть статистику по этим запросам.

![](https://habrastorage.org/webt/pd/ig/z1/pdigz16w5yckclnm9sofmaf0eba.png)

https://github.com/PostgreSQL-Consulting/pg-utils/blob/master/sql/global_reports/query_stat_total.sql

Мы pg_stat_statements используем для построения отчетов. Мы раз в сутки сбрасываем статистику. Накапливаем ее. Перед сбросом статистики в следующий раз, строим отчет. Вот ссылка на отчет. Вы можете его посмотреть.

![](https://habrastorage.org/webt/bv/lc/ae/bvlcae6xqoguu1cjoptouihb9yw.png)

Что мы делаем? Мы агрегируем суммой и подсчитываем общую статистику. Затем для каждого запроса мы считаем индивидуальный вклад. 

И что мы можем посмотреть? Мы можем посмотреть общее время выполнения этого запроса на фоне общей статистики. Можем посмотреть использование ресурсов процессора и ввода-вывода относительно общей картины. И уже оптимизировать эти запросы. Мы строим топ запросов по этому отчету и уже получаем пищу для размышления, что оптимизировать. 

![](https://habrastorage.org/webt/ff/8v/64/ff8v64xocel-fc4rasw5tkwxeng.png)

Что у нас осталось за кадром? Осталось несколько представлений (VIEWs), которые я не стал рассматривать, потому что время ограничено. 

Есть pgstattuple – это тоже contrib. Он позволяет оценить bloat таблицы, фрагментацию таблицы. И если фрагментация большая, нужно ее убирать, использовать разные инструменты. И функция `pgstattuple` работает долго. И чем больше таблиц, тем дольше она будет работать.

![](https://habrastorage.org/webt/2t/tw/8b/2ttw8bekfp6ttrhhtohj73x8x9k.png)

Следующий contrib – это `pg_buffercache`. Он позволяет проводить инспекцию шаредных буферов: какие буфера у нас используются, какие нет. И просто позволяет заглянуть в shared buffers и оценить происходящее там. 

Следующий модуль – это `pgfincore`. Он позволяет проводить низкоуровневые операции с таблицами через системный вызов `mincore()`, т. е. он позволяет загрузить таблицу в шаредные буфера, либо ее выгрузить. И позволяет помимо прочего проводить инспекцию страничного кэша операционной системы, т. е. то, насколько у нас таблица висит в page cache, в шаредных буферах и просто позволяет оценить загруженность таблицы.

Следующий модуль – `pg_stat_kcache`. Он также использует системный вызов. И вешает его перед выполнением запроса и после выполнения запроса. И смотрит в полученной метрике, сколько у нас запрос затратил на выполнение дискового ввода-вывода, т. е. операции с файловой системой и смотрит использование процессора. Однако модуль молодой и для своей работы он требует PostgreSQL 9.4 и pg_stat_statements, о котором я говорил ранее. 

![](https://habrastorage.org/webt/ba/dn/8i/badn8iutai1czfmf1iuuy8zvpsy.png)

- Умение пользоваться статистикой – полезно. Вам не нужны всякие программы. Вы можете сами заглянуть, посмотреть, что-то сделать, выполнить.  

- Пользоваться статистикой несложно, это обычный SQL. Вы собрали запрос, составили, отправили, посмотрели.  

- Статистика помогает ответить на вопросы. Если у вас возникают вопросы, вы обращаетесь к статистике – смотрите, делаете выводы, анализируете результаты.

- И экспериментируйте. Запросов много, данных много. Всегда можно оптимизировать какой-то уже существующий запрос. Можно сделать свою версию запроса, которая подходит вам больше, чем оригинал и использовать его.  

![](https://habrastorage.org/webt/m4/dr/e3/m4dre3esnukcqd59roitxsnzeea.png)

Годные ссылки, которые встречались в статье, по материалам которой, были в докладе. 

Автор пиши ещё
www.blog.postgresql-consulting.com (eng)
www.thislinux.org (rus)

The Statistics Collector
http://www.postgresql.org/docs/current/static/monitoring-stats.html

System Administration Functions
http://www.postgresql.org/docs/current/static/functions-admin.html

Contrib modules
http://www.postgresql.org/docs/current/static/pgstatstatements.html
http://www.postgresql.org/docs/current/static/pgstattuple.html
http://www.postgresql.org/docs/current/static/pgbuffercache.html
https://github.com/klando/pgfincore
https://github.com/dalibo/pg_stat_kcache

SQL utils and sql code examples
https://github.com/PostgreSQL-Consulting/pg-utils

И вот два блога. Один на английском, другой на русском. Если вам что-то хочется прочитать из моего творчества, то добро пожаловать!

