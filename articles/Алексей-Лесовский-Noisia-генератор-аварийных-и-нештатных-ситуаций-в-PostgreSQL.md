Noisia - генератор аварийных и нештатных ситуаций в PostgreSQL

![](https://habrastorage.org/webt/kg/hj/r5/kghjr52hinhseyhpquagpzsyf1i.png)

Добрый день! Меня зовут Алексей Лесовский. И в ближайшие 20 минут я буду рассказывать про инструмент, который позволяет создавать аварийные ситуации в PostgreSQL.

![](https://habrastorage.org/webt/i0/0d/zo/i00dzotbflkxp3hw5c9bxzgvbck.png)

Меня зовут Алексей Лесовский. И стандартный слайд – немного расскажу о себе. 

- Я PostgreSQL DBA и работаю в компании Data Egret. Наша компания занимается PostgreSQL-консалтингом и тех. поддержкой в сфере Postgres. 
- Кроме того, я системный администратор и делаю много разных вещей, связанных с системным администрированием в операционной системе Linux и всех служб, которые могут на ней работать. 
- Люблю различные мониторинги. Люблю разбираться со статистикой. И люблю разного рода визуализации. 

![](https://habrastorage.org/webt/xf/zt/hr/xfzthr7ycquk7vicimkqsanzdeu.png)

В этом докладе я буду рассказывать про инструмент, который сделал относительно недавно. Он называется [Noisia](https://github.com/lesovsky/noisia). Расскажу, зачем я его сделал и какая в нем есть функциональность. И расскажу о планах на будущее. 

![](https://habrastorage.org/webt/mr/5n/kl/mr5nklxn-z0ssvoegytpnb8rc2w.png)

Если говорить коротко, о чем будет доклад, то доклад будет о том, как контролируемо создавать аварийные ситуации в Postgres и как их контролируемо завершать. 

![](https://habrastorage.org/webt/8n/ro/cs/8nrocstufgkdf7mwpdmjjjlcw8w.png)

Зачем это могло понадобиться?

Когда-то давным-давно я делал самые разные скрипты, которые позволяли мне создавать такие проблемы. Цели были самые разные. Для каких-то конференций мне нужно было сделать демо, чтобы воспроизвести эти проблемы; где-то локально в разработке нужно было воспроизвести эти проблемы для последующих тестов. 

И всегда было важно соблюсти четкую грань, что нужно было запустить проблемы в определенном количестве, в определенный промежуток времени и в определенном объеме, т. е. не больше и не меньше. И все это было в одноразовых Shell-скриптах, которые я писал на коленке. Потом они складывались в отдельный каталог и там лежали до следующего раза. 

И когда мне нужно было что-то воспроизвести, я снова их доставал, что-то редактировал и снова использовал. 

Со временем скриптов накопилось довольно много. И я решил это все систематизировать и структурировать. 

![](https://habrastorage.org/webt/zn/zl/j6/znzlj6ibpsjlyf4xtlkvrpule5o.png)

В итоге появилась утилита. Она написана на языке Go, умеет работать в Linux. И она представляет собой консольный инструмент. Ее можно запускать в консоли, она подключается к Postgres и создает там аварийные ситуации по вашему запросу. 

Так как она написана на языке Go, то она дополнительно представлена в виде библиотеки. Вы можете встраивать ее в свои собственные приложения и использовать функциональность, которая доступна из этого пакета уже в своих собственных утилитах и инструментах. 

Очень важно отметить, что утилита позволяет создавать опасные ситуации, которые могут обрушить вашу базу данных, поэтому инструмент не предоставляет никаких гарантий с сохранением работоспособности БД. Инструмент предоставляется в свободной BSD-3 лицензии. Вы можете копировать код, модифицировать, предлагать свои изменения. 

![](https://habrastorage.org/webt/rs/27/o8/rs27o8zt1wqij3jsmetb-wsueee.png)

Давайте рассмотрим немного функциональность программы. На данный момент её относительно немного, но тем не менее любой DBA, в принципе, сталкивался с этими проблемами и, скорей всего, их как-то даже решал. 

В программе есть встроенная справка. С ее помощью можно посмотреть все имеющиеся сценарии, которые можно создавать и параметры, которые влияют на работу этих сценарий. 

Давайте пройдемся по этим сценариям и я коротко расскажу, что это все означает. 

**![](https://habrastorage.org/webt/zy/zm/r1/zyzmr11rqti3runwwcil3p1q3hm.png)**

Самый простой сценарий – это воспроизведение транзакций, которые ничего не делают. В Postgres они называются idle транзакции. Суть в том, что приложение подключается к базе, создает какие-то запросы и далее ничего не делает, не закрыв транзакцию. Эта незавершенная транзакция начинает тормозить работу базы данных. Если транзакция не завершается в течение долго времени это может привести к аварийной ситуации. 

Соответственно, Noisia позволяет создавать такие транзакции и позволяет указывать продолжительность такой транзакции: минимальную и максимальную. Плюс есть возможность указывать конкурентность. И конечно можно указать продолжительности теста. 

Конкурентность и продолжительность – это общие характеристики любого сценария которые я буду дальше описывать. 

**![](https://habrastorage.org/webt/yv/rm/td/yvrmtddpdpz8yf7fkp2rftsfvh0.png)**

Следующий сценарий – это транзакции, которые завершаются откатом (ROLLBACK). Postgres так устроен, что все запросы, которые заканчиваются с ошибкой, увеличивают счетчик откатов. По сути, этот счетчик можно рассматривать как счетчик ошибок. Таким образом, можно с помощью Noisia генерировать сценарий, где будет создаваться большое количество ошибок. 

Так же можно регулировать минимальную и максимальную частоту за период времени.  

И так же регулировать конкурентность и продолжительность. 

![](https://habrastorage.org/webt/q2/ys/em/q2ysemb0omea-obbyvqqqk8oqbe.png)

Можно пойти еще дальше и попробовать сгенерировать заблокированную транзакцию. Здесь у нас уже сценарий чуть сложнее. И появляется несколько транзакций, которые мешают друг другу. Они начинают бороться за один и тот же ресурс (как правило это строки). Одна транзакция пытается обновить строку или несколько строк, другая транзакция пытается также обновить эти же строки. В итоге вторая транзакция встает в ожидание и не может продолжить работу, пока не завершится первая транзакция. 

В этом сценарии также можно регулировать минимальное и максимальное время блокировки. 

И также доступна конкурентность и продолжительность, можно запустить столько блокировок, сколько хочется. 

![](https://habrastorage.org/webt/rd/yt/u1/rdytu11p19z9gkc8ttyzb65mdli.png)

Можно пойти дальше и сделать взаимоблокировки (deadlocks). Это уже более сложный пример блокировки, когда несколько транзакций имея занятые ресурсы пытаются взаимно получить доступ к ресурсам соседних транзакций. Это сложный конфликт и Postgres решает его через принудительное отключение какого одного из участников этой блокировки в надежде, что блокировка разрешится уже дальше сама. 

Здесь также можно указывать конкурентность, длительность. И можно регулировать количество взаимо-блокировок, которые нужно создать. 

![](https://habrastorage.org/webt/wu/hq/mm/wuhqmm-dl-qjol5tid8szvrkqki.png)

Следующий сценарий – это временные файлы. Здесь суть примерно такая – когда нужно сделать какую-то временную операцию типа сортировки или группировки, выделяется временная рабочая память для этой операции. 

И если памяти не хватает, то создается временный файл на диске. Все вычисления и результаты этой операции уже делаются с использованием файла на диске. За счет этого запрос становится медленней и появляется косвенная нагрузка на диск. Другие запросы которым требуется доступ к диску могут начать работать медленнее. 

Суть этого сценария в том, чтобы создать временные файлы и вызвать замедление в Postgres при работе с диском. 

Сценарий позволяет указывать количество временных создаваемых файлов и их размер. 

И также конкурентность и длительность.

![](https://habrastorage.org/webt/nn/6o/gp/nn6ogp2ynbku2wag-gmdvsvcrfi.png)

Другая функциональность уже связана с завершением процессов. Эта штука мне нравится больше. И я делал ее с большим воодушевлением. 

Суть сводится к тому, что Noisia с определенной случайностью завершает работу Postgres’овых процессов. 

Конечно же можно указывать частоту и интервал между завершениями процессов. 

Есть легкий режим, который позволяет отменять только запросы выполняемые процессами. 

И есть жесткий режим, который позволяет завершать непосредственно процессы. В таком случае, если какое-то приложение работало с базой и его процесс был завершен, то приложение получит ошибку. И зафиксирует это в своих журналах. 

И также есть более жестокий режим – это не жалеть системные фоновые процессы. У Postgres есть различные системные процессы типа autovacuum, checkpointer, процессы связанные с репликацией. И по умолчанию эти процессы исключаются из выборки, но можно сказать Noisia, что эти процессы тоже можно завершать. И можно будет посмотреть, как ведет себя Postgres.

И снова стандартные параметры, связанные с конкурентностью и длительностью.

![](https://habrastorage.org/webt/jh/6n/8n/jh6n8nvihx_h_lpoml5nsnykuow.png)

И последний доступный сценарий – это переполнение лимита подключений. Известно, что у Postgres есть стандартный лимит на количество подключаемых пользователей. По-умолчанию 100. Соответственно, к базе может подключиться только 100 пользователей. И если переполнить этот лимит, то к базе никто не сможет подключиться и база будет не доступна для работы приложения. 

Соответственно, Noisia тоже позволяет произвести этот сценарий и переполнить этот лимит, и сделать так, что другие приложения не смогут подключиться в этот момент к базе данных. 

Это достаточно простой сценарий. Его было легко сделать. И у него единственный параметр – это длительность самого сценария. 

![](https://habrastorage.org/webt/qz/kp/4m/qzkp4mnmwbumthy0dsbnigknifo.png)

Пока это вся доступная функциональность. Его можно использовать, на свой страх и риск. Возникают вопросы: «Зачем это может понадобиться?» и «Где это можно использовать?». 

На мой взгляд, самый распространенный пример – это обучение и тренировки для DBA и системных администраторов, чтобы они в боевых условиях могли ориентироваться, когда такие проблемы возникают в реальной базе. Можно создавать специальные сценарии, запускать их и по этим сценариям проводить обучение для DBA. 

Другой пример использования – это тестирование и Chaos engineering. Можно проводить испытания каких-то стендов тестовых или staging тестов и на них смотреть, как ведут себя наши приложения, когда в базах данных возникают ошибки. 

Особенно это интересно, когда ошибки связаны с отключением процессов или с переполнением лимита подключений. Интересно, как будет вести себя приложение; сможет ли оно повторно устанавливать приложение в случае, если подключение было отменено. Можно смотреть, насколько система устойчива к сбоям.

![](https://habrastorage.org/webt/k_/wb/dd/k_wbddnhri-wdjiqiugidgx--qg.png)

Планов на будущее довольно много. 

Начну с простого. Хочется как-то эмулировать различные рабочие нагрузки. Как вариант – можно симулировать последовательные проходы. По сути, это когда какой-то запрос читает полностью таблицу. Такой workload плох тем, что он вызывает нагрузку на диски. И если в таких запросах, которые он читает, много мелких таблиц, то это вызывает израсходование процессорных ресурсов. И такая нагрузка довольно вредная. И ее полезно обнаруживать, и уметь с ней бороться, например, через постройку соответствующих индексов.

Также есть мысль сделать эмуляцию нагрузки с разной долей чтения и записи, т. е. либо полностью read only нагрузка, либо write only нагрузка. И уже нагрузка, которая смешивает в разных долях читающую и пишущую нагрузку. 

![](https://habrastorage.org/webt/53/qh/ej/53qhejwc36gnnbpr84a8i-g_njc.png)

Другой план – это сделать сценарий, который позволяет исчерпать память на сервере. Суть в том, что если у нас, например, есть swap-область на сервере, мы с помощью какого-то хитрого запроса или, может быть, с помощью постоянного выделения памяти стараемся забрать всю свободную память в системе, в том числе и из кэша. И дальше попытаемся загнать систему либо в swap, либо вызвать OOM Killer. И протестировать, как Postgres будет работать в этих условиях. 

Если у нас система будет уходить в swap, то мы, скорее всего, будем ощущать какие-то тормоза. У нас будут медленно работать запросы, будут медленно работать диски. 

Если придет OOM Killer, то он, скорее всего, сложит Noisia, либо базу, либо какие-то другие системные процессы. 

В общем тут мы смотрим, насколько база устойчива к сбоям. 

![](https://habrastorage.org/webt/ty/9l/ow/ty9low6zsekwgzgnpe4vxfolpyq.png)

Другой сценарий, который тоже можно взять из предыдущего, когда приходит OOM Killer, то Postgres переходит в аварийный режим. Ему нужно отключить всех клиентов, запустить аварийное восстановление, прочитать WAL журналы и после этого он уже может принимать подключения. 

В этот момент база данных недоступна, не может обслуживать подключения. Это тоже аварийная ситуация и будет интересно посмотреть, как приложения работают в случае, если Postgres перешел в аварийный режим. 

Плюс, если у нас есть кластерные конфигурации, где используются автофайловеры, также интересно протестировать, как этот автофайловер будет работать в случае, если, допустим, основной узел ушел в аварийный recovery. Т. е. важно посмотреть переключение роли мастера на другой сервер. Посмотреть, как это происходит и как быстро.

![](https://habrastorage.org/webt/nd/zz/pr/ndzzprhvhfmetlfn68kczdwvjq4.png)

Также есть план сделать сценарий, который связан с работой репликации, т. е. можно приостановить репликацию, чтобы накопился какой-то lag репликации. Можно отстреливать системные процессы, которые связаны с работой этой репликации. На мастере – это wal sender, на реплике – это wal receiver. 

С помощью такого сценария можно тестировать кластеры, также тестировать работу switchovers, failovers. Можно посмотреть, как они будут работать в случае таких аварийных сценариях. 

![](https://habrastorage.org/webt/kw/za/hm/kwzahm_5c1gltasvki_asn1lycw.png)

И последний наиболее сложный сценарий, на мой взгляд, это вмешательство в рабочую нагрузку, которая есть на сервере. Предполагается, что в базе данных выполняются какие-то запросы, с БД работают какие-то приложения. И Noisia пытается как-то минимально проанализировать, что там работает и пытается негативно влиять на эту рабочую нагрузку. 

Самый простой пример – это поставить блокировку на какую-нибудь таблицу, где идет запись. Понятно, что в этом случае все запросы, которые пишут в эту таблицу, будут вставать на этой блокировке. Если ставить блокировки на короткое время, то мы получим тормозящие write-запросы. 

Другой вариант – это отключать какие-то горячие индексы. В таком случае запросы, которые пользуются этими индексами, будут вынуждены переключаться на другой индекс, либо использовать последовательный проход по таблице и тоже будут тормоза. 

Плюс можно как-то блокировать отдельные строки в отдельных таблицах и мешать пишущим запросам обновлять эти строки. Это похоже на полную блокировку таблицу, но чуть более гранулярный способ блокировки. Т. е. задача – вызвать waiting у отдельных запросов, при том, чтобы другие запросы, которые не вовлечены в обновлении этих строк, продолжали работать нормально. 

Это самая сложная штука, о которой я думал и на которую есть планы. Я надеюсь, что я ее в итоге сделаю. 

![](https://habrastorage.org/webt/9o/ei/gy/9oeigyaqf3s2bf8j3viqwsbtwom.png)

Это весь мой доклад. Привожу ссылку на проект. Называется он Noisia. Это дань уважения нидерландской группе, которая играет Drum & Bass. Заходите на страницу, ставьте звезды. В дискуссиях оставляйте свои комментарии. Если есть какие-то идеи, предлагайте, будет время я обязательно их рассмотрю, оценю и как-то, может быть, пообщаемся на эту тему. 

И еще раз напоминаю, что нет никаких гарантий, используйте инструмент на свой страх и риск. Он может запросто положить вашу базу и проблемы придется разгребать конкретно вам. 

![](https://habrastorage.org/webt/wn/mf/cg/wnmfcgktdbpfzmn-gxbqlxisctk.png)

На этом все. Большое спасибо! Задавайте вопросы.

**Вопросы**

Вопрос: Спасибо, Алексей, за интересный доклад про Noisia – генератора аварийных и нештатных ситуаций в Postgres. Алексей готов отвечать на ваши вопросы, которые вы можете задавать в чате. И первый вопрос: «В Go не очень качественные драйверы Postgres. Не используя стандартные Libpq, были проблемы с работой через PgBouncer. Почему был выбран Go, а не Python?».

Ответ: Начну отвечать с конца, почему был выбран Go, а не Python. Я являюсь разработчиком утилиты pgCenter. Она была написана на C. И я столкнулся с тем, что мне довольно сложно писать на C, потому что я не профессиональный разработчик. Мне нужно было выбрать какой-то более понятный мне язык. И Go показался мне гораздо более приятным, чем Python. Так исторически сложилось.

Потом, когда я уже делал следующие свои инструменты, и в том числе Noisia, выбора уже не было. Я сразу начал писать на Go.

Про драйверы. Сам по себе Libpq написан на C. Это нативный драйвер. И все остальные драйвера в других языках – это, по сути, какая-то оболочка поверх Libpq. И зритель верно подметил, что драйверы там не очень хорошего качества. Изначально я использовал драйвер lib/pq, но он ушел в стагнацию и сейчас, по-моему, не поддерживается. 

Плюс на сайте этого проекта есть ррекомендация в пользу pgx и я переключился на использование Pgx, тем более профессиональные разработчики на Go сами его используют в микросервисах и других проектах. И я тоже использую Pgx в своих утилитах. 

Но я недавно наткнулся на проблему. Pgx тоже не реализует всю доступную функциональность, которая есть в Libpq. Например, я недавно столкнулся с тем, что в обоих драйверах есть ограниченная поддержка переменных окружения. Это Libpq environment variables. В go'шных драйверах реализован ограниченный список, может быть, из 15-20 переменных, а остальные просто не поддерживаются. Вот такая проблема.

Работаю с тем, что есть. Драйвера для Postgres я еще не научился писать. Может быть, когда-нибудь напишу.  

Вопрос: Следующий вопрос от Андрея Евгеньевича Докучаева: «Есть ли мониторинг созданных утилитой проблем, а также их досрочный отстрел?».

Ответ: Это забавный вопрос. Нет, можно мониторить эти проблемы с помощью классической системы мониторинга, которая у вас есть. Например, Zabbix, Prometheus, SaaS-мониторинги. Ну и всегда можно нажать Ctrl+C и отменить запущенный сценарий.

Для чего я делал эту утилиту? Для того чтобы можно было в мониторингах эти проблемы отслеживать и потом уже от мониторинга переходить в консоли, и как-то их пытаться решать. По сути, все эти проблемы в хорошо настроенном мониторинге будут видны. Но если вы все-таки боитесь каких-то последствий, то лучше не использовать утилиту на важных базах данных. 

Вопрос: Следующий вопрос: «Не боитесь, что проблемы, генерируемые Noisia, будут вызваны некорректной работой собственной реализации Postgres-протокола в Go-драйвере?».

Ответ: Нет, я не боюсь, потому что я использую буквально несколько методов этой библиотеки. Это отправка запроса и вызов транзакции. Никакой сложной функциональности не задействовано. Эта функциональность очень хорошо протестирована, используется во многих проектах, поэтому я сомневаюсь, что какие-то проблемы вылезут на основе реализации именно драйвера 

Вопрос: Следующий вопрос от Сергея Новикова: «Планов на wraparound случайно нет? Или цель инструмента все-таки проверка работы приложения и автоматики при аварии, а не тренировка DBA?». 

Ответ: Это хороший задел на будущее. Возможно, я рассмотрю какую-то такую функциональность. Можно зайти на GitHub страницу проекта и добавить это в discussions, чтобы не забылось. У меня была мысль делать какие-то возможные коррупции данные. Но здесь нужно быть очень осторожным, потому что в интернете очень много специалистов, у которых слабые навыки и которые могут рискнуть запустить эту утилиту на какой-то базе данных и потом удивиться, почему у них база данных сломалась, несмотря на то, что даже disclaimer есть. Поэтому нужно взвесить за и против. Нужно понять действительно ли это нужно. Но мысль была у меня добавить коррупции. 

Вопрос: Максим Юрьевич Шерстюк: «Noisia можно скачать и попробовать?». 

Ответ: Да, можно скачать. На предпоследнем слайде была GitHub-страница проекта. Там есть раздел релизов, там есть архив с собранным бинарником. Есть rpm и deb-пакеты для установки. Можно установить и пользоваться. 

Вопрос: Роман Павлович Фролов спрашивает: «Будет ли реализованы сценарии, связанные с настройками ядра Linux, Sysctl –a, например. И хочу знать, как специфические настройки ядра влияют на работу PostgreSQL?».

Ответ: В плане работы Sysctl я не совсем понял вопрос. Этот вопрос нужно уточнить. А как Sysctl-настройки влияют? Тут все зависит от workload. И это уже отдельная тема, которая не относится к докладу. На самом деле то, как будет себя вести производительность Postgres, очень сильно зависит от того, какой workload, какие запросы и от ресурсов самого сервера. На мой взгляд, Sysctl-настройки в большинстве workloads практически не имеют значений. Они имеют значения только в пограничных сценариях на очень узкоспециализированных workloads.

Самый простой пример, который приходит в голову, это объем грязных страниц виртуальной памяти. В нормальной ситуации их крутить практически не приходится. И эти настройки нужно крутить только, если в Postgres большой объем данных на запись. 

Но практически большинство встречающихся workloads – это 99 % чтение и 1 % запись. Sysctl, на мой взгляд, редко, когда нужно править. Тем не менее есть 5-10 ключей, которые мы меняем от дефолтных. И этого хватает. 
