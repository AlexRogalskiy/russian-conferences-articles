**Расшифровка доклада 2018 года  Алексея Лесовского "Давайте отключим vacuum?!"**

Такой призыв часто возникает, когда в PostgreSQL возникают проблемы, и главным подозреваемым оказывается vacuum. По опыту, многие наступают на эти грабли, и мне с коллегам по Data Egret нередко приходится разгребать последствия, так как потом всё становится ещё хуже. Но если обратить внимание на сам vacuum, то, пожалуй, нет такого человека, который бы использовал Postgres, и при этом ничего не знал про вакуум. Ведь история вакуума начинается относительно давно, и в интернете можно найти массу как старых, так и новых постов про вакуум, объемные дискуссии в списках рассылки. Несмотря на то, что тема вакуума подробно описана в официальной документации к PostgreSQL, новые посты и новые дискуссии будут появляться и дальше. Возможно, поэтому с вакуумом связано очень много мифов, баек, страшилок и заблуждений. Между тем, вакуум является одним из важнейших компонентов PostgreSQL, и его работа напрямую сказывается на производительности. В одном докладе невозможно рассказать про вакуум абсолютно всё, но я бы хотел раскрыть ключевые моменты, связанные с вакуумом, такие как его внутреннее устройство, основные подходы к его настройке, наблюдение за производительностью, мониторинг, и что делать в случае, когда вакуум - главный подозреваемый во всех бедах. Ну и, конечно же, хочется развеять распространенные мифы и заблуждения, связанные с вакуумом.

![](https://habrastorage.org/webt/fx/sv/3m/fxsv3mqxulmnu4rdh_eipwrvvdm.png)

<cut />

Добрый день! Меня зовут Алексей. И сейчас я расскажу про вакуум: что бывает, когда специалисты берут и отключают вакуум. Расскажу, что происходит с базой и как не дойти до такой ситуации. И расскажу немного, как настраивать вакуум. В общем, буду рассказывать про вакуум и объяснять какие-то моменты, связанные с его работой.

![](https://habrastorage.org/webt/k0/q0/k_/k0q0k_kbdrqxy8aamojouthl0xe.png)

Начну я с того, как люди доходят до того, что отключают вакуум и о том, как им приходит в голову такая мысль. Далее расскажу, что происходит после отключения вакуума. И расскажу, как устроен вакуум и почему его нельзя отключать, как его лучше настраивать, чтобы не доводить до аномальных ситуаций.

![](https://habrastorage.org/webt/0v/nw/uv/0vnwuvq_xpyl4z2f32zfkyragsg.png)

Что бывает, когда люди приходят к мысли, чтобы отключить вакуум?

![](https://habrastorage.org/webt/3w/rp/kp/3wrpkpqbjqzuz6k3q8h_s3rzafy.png)

Очень часто отдел разработки приходят к администраторам баз данных или просто к системному администратору и говорит: «У нас тормозит вся база, приложение тупит. Нужно что-то делать. Смотрите, разбирайтесь». 

Как это выглядит? Как правило, админ запускает свою любимую утилиту. Смотрит нагрузку процессоров, смотрит нагрузку на диски и видит, что диски перегружены, утилизация – 100 % (самая дальняя колонка). И видит, что проблема действительно есть. И с этим нужно что-то делать. 

![](https://habrastorage.org/webt/r0/bi/6q/r0bi6qtbpbdhpmh95itmamo5fny.png)

Люди начинают смотреть, что у них с запросами. Открывают postgres’овый лог. Смотрят, в чем дело. Смотрят, сколько по времени выполняются запросы. И видят, что даже обычные операции занимают очень много времени. И это тоже проблема. И с этим нужно что-то делать. 

![](https://habrastorage.org/webt/ki/zn/id/kiznid6nupp9ofsryuotcz9olsk.png)

Отдел разработки начинает жаловаться, что у них отваливаются запросы. Если какие-то реплики используются для распределения нагрузки на чтение, в логе появляется сообщение, что запросы отвалились, т. е. реплики уже начинают не справляться. 

![](https://habrastorage.org/webt/7h/2u/3n/7h2u3nqb8mz019qfgwskfv3_23c.png)

И в какой-то момент отдел мониторинга, отдел саппорта смотрит и говорит: «О, у нас, кажется, реплика отвалилась. Есть проблемы». Т. е. произошла какая-то проблема, и реплики стали недоступными, и ситуация стала критической. И с этим нужно что-то делать.

![](https://habrastorage.org/webt/en/tn/lj/entnljkothqilsmlubxaxjmglsa.png)

И когда администратор дальше исследует проблему, он открывает, например, программу iotop и видит, что у него очень много запущено автовакуумов. Они все что-то делают. Они генерируют нагрузку на диск. Они создают большое количество журналов транзакций и реплики не успевают это все прожевать.

И это становится проблемой для базы данных. База данных начинает вести себя непредсказуемо в плане времени ответов на запросы и все это очень плохо сказывается на приложении. Приложение тупит, клиенты недовольны и бизнес страдает.

![](https://habrastorage.org/webt/5p/uh/zo/5puhzov2cqvzyprnnt2qpprrnme.png)

Что делать в этой ситуации? Начинаются какие-то попытки тюнинга вакуума, какие-то попытки исправить ситуацию. Начинают пристреливать вакуумы. Вакуумы запускаются снова. Проблема не решается. 

![](https://habrastorage.org/webt/jg/vf/g3/jgvfg34k-xk3l2xryqvjukmixd4.png)

И в какой-то момент кто-то предлагает: «Давайте отключим вакуум. Есть такая крутилка – автовакуум. Давайте выставим ее в выключенном состоянии и будем дальше работать». 

![](https://habrastorage.org/webt/ed/ui/p6/eduip6msje8zxkrqnh4-8vabosg.png)

И отключают, и вроде бы все хорошо, кажется, что приложение начало работать нормально: данные читаются, запросы выполняются быстро. Все хорошо у нас с данными. И клиенты вроде бы не страдают. 

Но есть несколько моментов, которые в долгосрочной перспективе выйдут боком и сделают только хуже. 

- Самый простой и очевидный момент – это то, что статистика планировщика перестает собираться. Потому что автовакуум не только чистит таблицы, а еще и собирает статистику распределения данных. И эта статистика используется планировщиком для того, чтобы построить оптимальные планы для запросов.  
- Как только мы выключаем вакуум, таблицы и индексы перестают чиститься. И они начинают пухнуть. В них появляются мусорные строки. Таблицы и индексы начинают расти в размерах.  
- Следствием этого является то, что область shared buffers, где размещаются все оперативные данные для работы базы данных (это таблицы, индексы), начинается использоваться неэффективно. В ней находятся те самые мусорные строки. И чтобы запросу прочитать какие-то данные, ему нужно загружать страницу с мусорными данными и поместить ее в shared buffers.  
- И все это очень плохо с точки зрения общей производительности. Производительность запросов падает. И в долгосрочной перспективе отключение вакуума – это несет плохие эффекты.  

![](https://habrastorage.org/webt/lc/do/dt/lcdodt4jbsygkgp8jx041vcbfsw.png)

Все это можно быстро воспроизвести. Есть небольшой тест. Я его готовил для одной конференции. Он находится по вот этой ссылке: https://github.com/lesovsky/ConferenceStuff/tree/master/2016.highload

Что происходит в этом тесте? Мы запускаем pgbench на отключенной таблице. Этот pgbench выполняет запись в таблицу, а также удаление, апдейты. И в какой-то момент мы можем наблюдать падение производительности. Время выполнения запросов увеличивается, а количество транзакций в секунду падает. Т. е. на таком коротком тесте можно понаблюдать, как падает производительность при отключенном вакууме. 

![](https://habrastorage.org/webt/cb/xd/97/cbxd97cteefhstwlddgwori2ajc.png)

И сейчас стоит рассказать про вакуум. Рассказать, как он работает и зачем он нужен. Многие администраторы, многие разработчики, с которыми я общаюсь, имеют довольно-таки расплывчатые понимания об автовакууме. И даже люди, которые пишут патчи для Postgres, про автовакуум знают отрывочно, обрывочно. И поэтому я сейчас расскажу про вакуум. И какую целостную-то картину о нем попробую у вас сформировать.

![](https://habrastorage.org/webt/we/ts/d9/wetsd9tb46ev3juckcwk9ezt2ta.png)

Для начала нужно рассказать, что такое MVCC.

MVCC – это движок базы данных, движок Postgres, т. е. как база данных предоставляет данные клиентами. 

- И этот движок очень производительный. Он обеспечивает очень хорошую конкурентность. Клиенты могут подключаться к базе данных и работать параллельно друг с другом.  
- И обеспечивается хорошая производительность базы данных на чтение и запись.  
- При этом движке читатели не блокируют читателей; писатели не блокируют писателей за исключением некоторых ситуаций таких, как deadlock и других ограниченных ситуаций.  

![](https://habrastorage.org/webt/eo/qt/lc/eoqtlcif0e8ox_ihwmuqclbgwew.png)

Как это выглядит на практике? К базе данных подключаются клиенты. И открывая транзакции они начинают работать с данными. Они получают снимок данных. 

![](https://habrastorage.org/webt/d-/zx/ja/d-zxjayq6qlxhpcu2bfxythgtqm.png)

И в этих данных они могут делать какие-то изменения: вставку новых записей и удаление существующих или обновления. И все эти изменения в рамках транзакции не видны другим транзакциям до тех пор, пока не произойдет commit или rollback. 

![](https://habrastorage.org/webt/6z/ph/sb/6zphsbe6c9bckavrgr_fgbknwme.png)

Как только транзакция выполняет операцию «commit», то ее изменения могут быть видны другим транзакциям, которые уже открываются или работают в данный момент. 

И так это все работает. Счетчик транзакций растет, данные появляются. Какие-то данные становятся неактуальными, потому что происходят операции «delete», «update». Появляются мусорные строки. 

![](https://habrastorage.org/webt/iw/kx/w0/iwkxw0lsgd6tagswlyis5m65ouu.png)

В строках есть две служебные записи. Первая служебная запись – это такая называемый xmin. Она показывает номер транзакции, которая произвела вставку строки. Т. е. когда мы делаем insert, то в этот xmin записывается значение транзакции. 

Когда мы делаем обновление строки, то это не такой in-place update, на самом деле это мы помечаем строку как удаленную и вставляем новую строку как новую. И в удаленной строке мы помечаем в поле xmax номер той транзакции, которая произвела удаление. 

И delete. Здесь все просто. Мы строку помечаем как удаленную. Заполняем поле xmax. И она становится удаленной. 

И за счет этого в базе данных появляются мусорные строки. Это те строки, которыми заполнено поле xmax.

![](https://habrastorage.org/webt/8i/-c/cg/8i-ccgu38dh9ydkg7ue9sk1qqn0.png)

И зачем нужен вакуум? Вакуум нужен для того, чтобы чистить эти строки, которые уже не нужны ни одной транзакции и которые можно безопасно удалить и место в таблице, в индексе использовать повторно. 

Выглядит это вот таким образом на уровне страниц. У нас есть некоторые указатели, по которым запросы определяют в какую область страницу нужно сходить и прочитать эти данные. Эти указатели указывают на сами строки.

![](https://habrastorage.org/webt/7r/cq/f1/7rcqf1nzi4dtbmownh9rqfchbz4.png)

Когда операции «delete», «update» работают со страницей, то некоторые версии строк становятся устаревшими. И их нужно будет потом почистить. Их нужно будет потом почистить, потому что они в какой-то момент станут не нужны ни одной из транзакции.

![](https://habrastorage.org/webt/fd/0h/fc/fd0hfcbvlzr83cdaf4ktpwlszoc.png)

Приходит вакуум. Он освобождает указатели и делает их доступными для повторного использования. Вычищает устаревшие версии из строк. 

![](https://habrastorage.org/webt/xh/pu/mb/xhpumb0tkvun4urwv534i0s1gje.png)

И в итоге в странице появляется новое место, которое можно использовать для дальнейшей записи, для дальнейших inserts, updates и т. д. 

![](https://habrastorage.org/webt/17/fu/kg/17fukg6fvv_ttf4jdwub_mk27ho.png)

- И как раз вакуум нужен для того, чтобы сохранить общую производительность, чтобы держать таблицы, индексы в тонусе, чтобы производительность не страдала, чтобы устаревшие версии строк вычищались.
- И чтобы область shared buffers использовалась эффективно.  
- И чтобы не было эффекта «bloat», не было эффекта раздувания. Чтобы база была в тонусе, чтобы в ней не было распухания.  

![](https://habrastorage.org/webt/5u/sn/se/5usnsewb85uihdn5nenam9yjf2c.png)

И здесь мы уже подходим к вакууму. Как обстоят дела с вакуумом?

- Во-первых, это фоновая задача.  
- Когда мы запускаем Postgres, запускается demon автовакуума. Он периодически запускает там своих воркеров. И количество этих воркеров ограничено. Т. е. мы можем регулировать количество воркеров и сделать так, что в какой-то конкретный момент времени их будет работать максимально ограниченное количество.  
- Автовакуум запускается с некоторым интервалом.  Этот интервал тоже регулируется. Мы можем на него влиять.  
- И один из важных моментов – автовакуум собирает статистику для планировщика. Я уже об этом говорил. И статистика для планировщика собирается. И планировщик на основе этой статистики может генерировать нормальные планы. Данные будут вытаскивать из базы данных наиболее эффективным образом.  

![](https://habrastorage.org/webt/ew/8v/dt/ew8vdtf5y49avskvvnunodanele.png)

- Автовакуум запускается и ему нужно выбрать какую-то базу. Понятно, что в кластере, в instance Postgres баз данных может быть очень много.  И нельзя просто взять алфавитный список, и потом по нему идти гулять.  
- Автовакуум выбирает те базы данных, которые давным-давно не обрабатывались.  
- Либо он выбирает те базы, где есть риск оборачивания этого счетчика транзакций. Счетчик транзакции ограничен 32 битами. Он 32-х битный и он всего 4294967296. И когда в базе очень большая запись, счетчик транзакций может в какой-то момент переполниться. Для этого есть wraparound vacuum, он как раз борется с этой проблемой. Но wraparound vacuum нам сейчас не интересен.  
- И когда база данных выбрана, нужно уже выбрать те таблицы, которые нужно обработать. Тут тоже нельзя просто взять алфавитный список и начать как-то по нему работать. Для выбора таблиц существует формула. Я дальше про нее расскажу. Эта формула оперирует количеством мертвых строк в таблице. Как только количество мертвых строк в таблице превышает какой-то порог, эта таблица помещается в список на обработку. И когда список на обработку уже построен, vacuum worker начинает эти таблицы обрабатывать.  

![](https://habrastorage.org/webt/oo/kv/w0/ookvw0ol3x-fulqpcltgnhw9zwe.png)

- **Настройки по умолчанию никуда не годятся.** Вообще подход разработчиков к конфигу Postgres такой, что Postgres должен запуститься на любом оборудовании, на самом старом утюге, на самом старом Pentium, чтобы разработчик, пользователь мог начать пользоваться базой и как-то с ней экспериментировать, работать. И всегда эти настройки приходится пересматривать. Очень часто, когда мы приходим к клиенту, проводим аудит его базы данных, аудит конфигов, то мы видим, что **настройки автовакуума стоят по умолчанию, либо они как-то неадекватно выставлены.** И к этому нужно всегда внимательно относиться.  
- Но Postgres не стоит на месте. Он развивается. И всякие разные тюнинги автовакуума от версии к версии тоже происходят. И наиболее значительные произошли в версии 9.6. Там много улучшений, поэтому если вы используете версии меньше 9.6 и имеете проблемы с вакуумом, то имеет смысл обновиться до версии 9.6.  

![](https://habrastorage.org/webt/ob/n6/cn/obn6cnkpbariycrvnlrqxloa2se.png)

Вроде с вакуум теперь более-менее понятно. Теперь нужно его настроить. Нужно открыть конфиг, посмотреть, где он настраивается. Нужно приложить какие-то усилия, чтобы вакуум заработал.

![](https://habrastorage.org/webt/_w/bj/66/_wbj66wqi-nindu2znh5gsnjqna.png)

Во-первых, про вакуум всегда следует помнить, что он так называемый оценочный. Он основан на оценках. И за эти оценки отвечают несколько параметров. 

Вакуум работает таким образом. У него есть счетчик очков. Когда он начинает обрабатывать таблицу, он начинает читать страницы. И за обработку каждой страницы начисляется определенное количество очков. 

Как только счетчик очков дошел до какого-то значения, воркер делает паузу на определенное количество времени. После этой паузы он сбрасывает счетчик в ноль и начинает снова обрабатывать таблицу. Это классическая обработка. 

И за начисление очков при обработке страницы отвечают несколько параметров. Это hit, miss, dirty.

**Hit** – это количество очков, начисляемые за обработку страниц, которые находятся в шаредной памяти, т. е. это самая дешевая обработка. Уже в шаредной памяти мы со страницей что-то сделали: прочитали, обработали. 

**Miss** – это если страницу нужно прочитать с диска. Ее нет в шаредной памяти. И уже нужны какие-то ресурсы потратить на ее чтение. Здесь уже начисляется больше очков, потому что страницу нужно прочитать с диска. Но бывает ситуации, когда страницы вроде бы и нет в шаредной памяти, но это не означает, что она на самом деле на диске. Она может быть в страничном кэше операционной системы. И это тоже затрата ресурсов, хоть и не такая большая. 

**Dirty** – это количество очков, которые начисляются за обработку страниц, если ее при этом нужно записать на диск. Т. е. какие-то изменения нужно сбросить на диск и это более дорогая операция. 

Таким образом за обработку страниц начисляются очки. И они начисляются до параметра **vacuum_cost_limit**. Этот параметр как раз определяет у нас размер пачки. Сколько очков начисляться, столько страниц более-мене обработано. И нужно делать паузу.

Пауза определяется параметром **vacuum_cost_delay**. Тут уже понятно, что мы с помощью cost’а можем влиять на размер пачки. А с помощью delay можем влиять на интервал сна. 

И таким образом вакуум можно делать либо агрессивным, когда он обрабатывает помногу страниц и спит очень мало времени, либо делать вакуум ленивым, когда он обрабатывает мало страниц и подолгу спит. Всегда стоит помнить вот эту особенность вакуума при его настройке. Это очень важно. 

![](https://habrastorage.org/webt/km/tg/ci/kmtgcideecl9aqsljdkwouizedw.png)

Во-вторых, рабочих может быть много. По умолчанию количество воркеров максимальное, которые могут работать вместе, три штуки. 

- На современных серверах, когда количество процессорных ядер уже переваливает за 32 и более, этот параметр следует увеличивать в большую сторону. **И, на мой взгляд, оптимальным значением autovacuum_max_workers является примерно 10-15 % от общего количества ядер.**  
- Следующий параметр **autovacuum_naptime**. Он определяет, как часто нужно запускать autovacuum worker. **По умолчанию он равен 60 секунд. И это довольно большое значение. Имеет смысл его уменьшать до 1 секунды, до 2 секунд, до 5 секунд**. Опыт показывает, что одной секунды достаточно с точки зрения кода postgres’ового. Там небольшая функция, которая отсчитывает таймер и смотрит – не пора ли нам запустить вакуум. Т. е. это не ресурсоемкая операция. Имеет смысл всегда ее уменьшать.
- И другой важный момент – это то, что параметр **vacuum_cost_limit**, который влияет на размер пачки, он делится всегда между теми активными воркерами, которые запущены прямо сейчас. Это тоже следует помнить, **vacuum_cost_limit** следует делить между всеми воркерами.  

![](https://habrastorage.org/webt/oo/2e/47/oo2e47hrh4hxob8jvyjjucjc0ly.png)

В-третьих, нам нужно вакуум оценить, т. е. сколько мертвых строк в таблице. Для этого используется обычная формула, которая определяет количество мертвых строк. И с помощью вот этой величины мертвых строк она определяет – не пора ли нам запустить вакуум. 

И рассчитывается она таким образом. Мы берем количество строк в таблице с момента последнего выполнения вакуума и умножаем на переменную **autovacuum_vacuum_scale_factor**. Это, условно говоря, такое дробное число. Это процентное отношение. Допустим, по умолчанию это 0,2, т. е. 20 %. 

К полученному числу мы добавляем значение **autovacuum_vacuum_threshold**. Там по умолчанию – это 50 строк. И получаем тот самый порог, выше которого нужно запустить автовакуум. 

![](https://habrastorage.org/webt/63/en/ti/63enti4gfce93el_fce3twqvrso.png)

Таким образом вакуум запускается по умолчанию, если мертвых строк в таблице более 20 %. На больших таблицах это очень большой порог, поэтому всегда имеет смысл **autovacuum_vacuum_threshold** уменьшать и делать, например, 1-2-5 %. 

![](https://habrastorage.org/webt/zi/1s/oq/zi1soqr-3vks3mqnxi1hcr1bsyo.png)

И бывают ситуации, когда регулирование с помощью **autovacuum_vacuum_scale_factor** не приносит должного эффекта. Особенно это на больших таблицах себя проявляет. Когда внутри таблицы миллионы строк, то даже 1 % - это очень большое количество строк. Тогда имеет смысл поставить **autovacuum_vacuum_scale_factor** в 0. И пользоваться только **autovacuum_vacuum_threshold** параметром, т. е. явно указывать, что запустить вакуум после одного миллиона строк. Когда у нас появилось миллион мертвых строк в таблице, то нужно запустить вакуум. Нужно выбирать: либо мы **autovacuum_vacuum_scale_factor** используем для каких-то индивидуальных таблиц, либо **autovacuum_vacuum_threshold** для них. 

![](https://habrastorage.org/webt/rm/jj/r3/rmjjr3cxwqz4cxutagmm9gcnujo.png)

Также настройки автовакуума зависят от того, какое у вас оборудование. Года 4-5 назад, когда HDD диски встречались практически повсеместно, настройкам вакуума нужно было уделять очень большое внимание. Потому что убить HDD диски и их производительность очень легко. Запускаем много воркеров, делаем агрессивный вакуум и все, мы получили просадку по производительности. И нужно уже, наоборот, делать вакуум менее ленивым, тюнить его. 

С SSD дисками ситуация более-менее выправилась хорошо. И дефолтный вакуум на SSD дисках всегда приходится пересматривать и делать его агрессивным. Это первая задача, которая возникает при аудите. 

Но производительности SSD дисков тоже не всегда хватает. Бывают ситуации, когда ставятся в сервер кастомерские диски. И на высокой конкурентности, когда много запросов (пишущих, читающих), их производительность тоже страдает. Поэтому всегда рекомендация – ставить интерпрайзные диски серверные, которые такой проблеме не особо подвержены. 

И если вы используете NVME диски, то проблемы вакуума как таковой вообще нет, потому что это очень производительные устройства. И там вопрос I/O практически никогда не стоит. Там можно делать агрессивный автовакуум, делать много воркеров и вообще не париться. Единственное, что нужно настроить мониторинг и все-таки следить – нет ли каких-то проблем с автовакуумом в процессе работы базы. Поэтому чем лучше оборудование, тем проблемы IO, связанные с вакуумом, становятся меньше.

![](https://habrastorage.org/webt/_w/ui/pp/_wuippkoa0tusm7tvz2tke2admk.png)

И здесь можно вывести какое-то общее правило. Мы регулируем **vacuum_cost_delay** и **vacuum_cost_limit**. Это интервал сна между обработкой и размером пачки. Т. е. всегда нужно отталкиваться от этого. Вы регулируете размер пачки. Регулируете интервал. Смотрите мониторинг. Смотрите – есть ли у вас проблемы или нет. 

Если есть проблемы, вы продолжаете дальше тюнинг. Если проблем не наблюдается, вы можете оставить такие настройки, как есть и жить спокойно. 

![](https://habrastorage.org/webt/il/wp/7r/ilwp7rhrlmrv9kmau_4z2__plca.png)

```
vacuum_cost_delay = 0
vacuum_cost_page_hit = 0
vacuum_cost_page_miss = 5
vacuum_cost_page_dirty = 5
vacuum_cost_limit = 200
--
autovacuum_max_workers = 10
autovacuum_naptime = 1s
autovacuum_vacuum_threshold = 50
autovacuum_analyze_threshold = 50
autovacuum_vacuum_scale_factor = 0.05
autovacuum_analyze_scale_factor = 0.05
autovacuum_vacuum_cost_delay = 5ms
autovacuum_vacuum_cost_limit = -1
```

И здесь я привожу пример настройки для SSD дисков, которые мы используем на разных клиентах. В принципе, вы можете скачать эти слайды и потом эти настройки применить у себя, и отталкиваться уже от них. 

**Но здесь важное замечание: это настройки для SSD.**

![](https://habrastorage.org/webt/ix/sd/ob/ixsdobjhrykz7d6mzhdorx66_n0.png)

Когда мы настраиваем вакуум, бывают ситуации, когда нужно какие-то индивидуальные параметры для таблицы или для индекса выставить. Это тоже часто бывает. Например, какие-то огромные таблицы или какие-то маленькие таблицы, кто-то решил изобрести очереди у себя в базе и там нужно часто запускать вакуум. 

Для таких случаев можно использовать индивидуальные параметры вакуумов, которые определяются через storage_parameter. Их можно определять для tablespace, для таблиц, для индексов. Это тоже очень хорошая штука, про которую стоит помнить.


![](https://habrastorage.org/webt/tf/qp/pf/tfqppfseyswfcbfn4fvxsv-74d4.png)

И бывают случаи, когда автовакуум простой не помогает, поэтому приходится прибегать к каким-то сторонним средствам, которых нет в штатной поставке Postgres. Это, как правило, утилиты [pgcompacttable](https://github.com/dataegret/pgcompacttable) и [pg_repack](https://github.com/reorg/pg_repack).

Они позволяют уменьшить bloat таблиц с помощью своих определенных методик. 

У этих двух таблиц методики разные, поэтому рекомендуется на тестовых серверах попробовать ознакомиться с их кодом, посмотреть, как они работают. Результат всегда одинаковый – база, таблица или индекс всегда уменьшаются в размере и приводятся в тонус хороший. Поэтому очень рекомендую эти утилиты. 

![](https://habrastorage.org/webt/jj/ct/4r/jjct4rtt6pjarvfjpifbvfzt39i.png)

Раз я говорил про мониторинг, то следует немного рассказать, как мониторить вакуум. И здесь довольно-таки все просто. 

В Postgres есть два места, где можно смотреть, что происходит с вакуумом. 

Первое – это pg_stat_activity. И, как мне кажется, данные из этой вьюхи должны быть в любом мониторинге, потому что она показывает текущую активность в базе данных, в том числе и для автовакуума.

В этой вьюхе мы можем смотреть количество вакуумом, сколько их сейчас работает и текущее состояние, нет ли на них блокировок, а также возраст выполнения. Т. е. мы всегда можем через pg_stat_atctivity посмотреть, сколько вакуумов выполняется и как долго. 

![](https://habrastorage.org/webt/ad/s1/r3/ads1r32i9l8xq6p0yplfgalwuv8.png)

Вот так выглядит, например, классический график в системе мониторинга. У нас есть информация о количестве воркеров, т. е. сколько в wraparound воркеров работает. И можем смотреть максимальный лимит – не превышаем ли мы, не уперлись ли мы в потолок по количеству воркеров. 

С помощью такого графика можно легко анализировать – нет ли у нас проблем. Если мы уперлись в красную линию, значит, у нас долгие воркеры, у нас их мало запущено и нужно как-то их делать агрессивнее, тюнить, увеличивать количество воркеров. И нужно смотреть на длительность их выполнения. Т. е. всем рекомендую такой график иметь у себя в системе мониторинга.

![](https://habrastorage.org/webt/iv/kt/be/ivktbevhwtimzgspbkqf-x_y9we.png)

Второе место, которое следует смотреть, это вьюха, которая появилась в версии 9.6. Это pg_stat_progress_vacuum. Она показывает текущие воркеры, которые сейчас работают в базе данных. И показывает прогресс их выполнения. 

По умолчанию это такая скучная вьюха, в которой сырые данные и не понятно, что эти цифры означают. Поэтому если использовать pg_stat_activity и некоторую информацию оттуда, плюс взять системные функции, которые показывают размеры таблиц, индексов в человекопонятном виде (в килобайтах, мегабайтах), то можно примерно вот такой запрос сделать. 

![](https://habrastorage.org/webt/rt/xk/fw/rtxkfw2t_nmyn3fuxgpa55eavag.png)

https://github.com/lesovsky/uber-scripts/blob/master/postgresql/sql/vacuum_activity.sql

Он показывает, какой у нас вакуум запущен, его длительность выполнения, на какой таблице он работает и какой у него прогресс. Т. е. в данном случае можно наблюдать, что у нас вакуум обрабатывает примерно 50 % таблицы и он еще будет работать примерно столько же. Если он 3 часа проработал, то примерно будет работать еще 3 часа. 

С помощью этой вьюхи можно примерно оценивать прогресс вакуума: как долго он будет работать, как скоро он закончится. Тоже очень полезная вьюха. Тоже рекомендую использовать ее в своем вооружении.

![](https://habrastorage.org/webt/f8/bo/db/f8bodbtuoqugyofhyzvcqqlrv40.png)

- **Вакуум отключать ни в коем случае нельзя. Это очень нужная для базы данных штука.**   
- Настраивать вакуум не сложно. Если знать его конкретные принципы работы, то вы всегда можете от этих принципов отталкиваться и использовать какие-то конкретные параметры: выставлять их, анализировать и смотреть – не стало ли хуже, лучше. Конечно, нужно использовать мониторинг, чтобы всегда смотреть, как изменилась работа базы данных при изменении этих настроек. Это очень важно.  
- И вакуум – это хорошо. Он позволяет держать базу в тонусе, чтобы она не пухла, поэтому никогда не отключайте вакуум.

Вопросы

*Здравствуйте! Спасибо за доклад! Меня зовут Андрей. В 9.6 обещали сильно оптимизировать вакуум именно на данных, которые не меняются.*

Да-да.

*Но на боевом сервере все равно вижу постоянно, что партиции, данные которые не меняются, они постоянно вакуумируются. Можно этот момент как-то прояснить? Может быть, я что-то неправильно настроил?*

Все верно. В 9.6 появилась freeze-карта, которая показывает замороженные блоки и позволяет избегать их обработки во время вакуума. Есть также в postgres’овом конфиге опции, которые влияют на срабатывание этого wraparound vacuum. Нужно просто их увеличить, чтобы этот вакуум срабатывал реже. Но, по идее, этот вакуум должен быть легковесным. Он пробегает по таблице. Видит, что все блоки находятся в заморозке. Он выполняется быстрее, он не использует ресурсы сервера, как если бы он использовал их в 9.5 и ниже. Он становится более легковесным, но обработка страниц никуда не девается. Он просто читает headers страниц и видит, что строки заморожены и можно в эту таблицу не ходить. 

*Я правильно понимаю, что если вакуум агрессивный читает страницу и ее нет в buffer cache, он с диска делает read?*

Нет, когда autovacuum worker запускается, то там есть buffer-менеджер. Он для автовакуума использует размер буфера 32 килобайта, по-моему. Т. е. это кольцевой буфер, через который строки прогоняются. Т. е. кэш не вымывается. 

*Он делает чтение страниц с диска?*

Да. Page_cache она вымывает. Данные появляются в page_cache, а шаредный буфер она не вымывает. Все верно. Page_cache вымывается.

*Алексей, много полезного и интересного! Единственный момент, мы столкнулись с такой ситуацией. У нас есть хосты, на которых по сотням тысяч таблиц. И time там стоял дефолтный. По 5 или 1 минуты, не помню. У нас все сшибало капитально. Мы вынуждены были в свое время снизить его до раза в сутки, потому что у нас каждые 5 минут ресурсы упирались под 100 % и по CPU, и по storage. При этом диски у нас быстрые.* 

Здесь вариант – это увеличивать количество воркеров. Много таблиц – много воркеров. Но если вы упираетесь в количество CPU, нужно как-то расширять мощности сервера. И есть такой интересный момент – какая схема энергосбережения процессором используется? Очень часто люди работают с Ubuntu и на ней гоняют базу данных. И у Ubuntu дефолтная настройка для схемы энергосбережения процессора power safe. Т. е., условно говоря, в сервере стоит процессор 3,4 GHz, а на тактовой частоте он работает – 1,2. Т. е. это очень плохо. Мы в таких случаях делаем перфоманс governor. И он работает на максимальной частоте. Он, конечно, греет атмосферу, все плохо, но, по крайней мере, запросы начинают быстрее выполняться. И задачи, связанные с вычислением на процессорах, тоже начинают работать быстрее. 

В вашем случае нужно посмотреть схемы энергосбережения и попробовать увеличивать количество воркеров через увеличение ядер. Если диски не справляются, то это тоже увеличение дисков, т. е. нельзя получить какую-то серебряную пулю, чтобы диски не просаживались и вакуум держал все время в тонусе. Либо мы какой-то bloat все-таки допускаем в базе и позволяем, чтобы вакуум работал медленнее и при этом диски не страдали. Либо делаем апгрейд железа и позволяем вакууму работать более агрессивно. 

*Спасибо за доклад! Предположим, что у нас есть две открытые транзакции. В одной из транзакций мы изменяем данные: удаляем или обновляем. Автоматически спустя какое-то количество autovacuum_vacuum_scale_factor или autovacuum_vacuum_threshold начинает выполняться как  .При этом записи он не может освободить, потому что открыта вторая транзакция, которая снапшот, которая видит еще эти строки. И в итоге получается, что naptime секунд автовакуум портит статистику, если выполняется без analyze. Причем в текущей версии Postgres в каждой статистике добавляется еще количество мертвых строк. Это отражается в pg_class reltuples*

Да-да.

*С каждым вакуумом число увеличивается. И это влияет на планы запросов.* 

Да. 

*Для того чтобы не добавлялось к этому значению количество dead tuples в community я нашел патч, который сделали разработчики 2ndQuadrant. Протестировал – работает. Но тем не менее каждый вакуум без analyze увеличивает количество reltuples и портит статистику.*

Да, портит статистику. Основная идея – это избегать долгих транзакций. Уменьшить их длину жизни. **Следить за тем, чтобы они не были в статусе «idle in transactions», чтобы база данных не ожидала, когда придет следующая команда от клиента.** Не делать в транзакции какие-то обращения к внешним ресурсам. Вот это основная рекомендация, т. е. уменьшить время жизни транзакции и следить, чтобы они не тупили. 

*Это понятно, но за баг это не считается?*

Да, это такое поведение MVCC и самого вакуума. Если эти строки потенциально могут понадобиться каким-то другим транзакциям, то чистить их нельзя.

*Зачем каждый раз увеличивать количество reltuples?*

Сложный вопрос. Сходу не отвечу. 

*(другой спикер) Я могу сказать. Не надо думать, что это вакуум увеличивает. Увеличивает ваша транзакция: update, insert и т. д. Вакуум это всего лишь приведение статистики в порядок: то, что реально есть в таблице. Он не увеличивает количество tuples. Он может только уменьшить.*

Да, т. е. за счет открытой транзакции появляются новые записи, которые вставляются другими транзакциями. И изменения незаконченной транзакции добавляются к этой статистике. И reltuples обновляется вакуумом. Когда вакуум закончился по таблице, он посчитал количество строк, с учетом всех транзакций висящих, и это значение зафиксировал, записал. Т. е. он не может какую-то аналитику там сделать – понадобятся или не понадобятся. Он просто в тупую их фиксирует. 

*Вы упоминали о том, что вакуум напрямую связан с планировщиком. А через какие механизмы автовакуум взаимодействует или оказывает какое-либо влияние на планировщика запросов?* 

В postgres’овом коде есть отдельные функции, которые собирают статистику о распределении данных внутри таблиц. Это отдельная подсистема автовакуума. Он читает какой-то sample данных из таблицы. И на основе ее строит распределение по данным. И эту информацию он сохраняет в системной вьюхе pg_statistic или в pg_stats. И когда планировщик строит планы запросов, он читает информацию из этой таблицы. И на ее основе строит планы. И дальше уже выбирает оптимальный. 
