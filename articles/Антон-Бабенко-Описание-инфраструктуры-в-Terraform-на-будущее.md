**Описание инфраструктуры в Terraform на будущее / Антон Бабенко (terraform-aws-modules)**

![](https://habrastorage.org/webt/2t/w-/cx/2tw-cxkjewlvus-otixblhw5i8a.jpeg)

Многие знают и используют Terraform в повседневной работе, но для него до сих пор не сформировались лучшие практики. Каждой команде приходится изобретать свои подходы, методы.

Ваша инфраструктура почти наверняка начинается просто: несколько ресурсов + несколько разработчиков. Со временем она растёт во всевозможные стороны. Вы находите способы сгруппировать ресурсы в Terraform-модули, организовать код по папкам, и что здесь вообще может пойти не так? (известные последние слова)

Проходит время, и вы чувствуете, что ваша инфраструктура — это ваш новый питомец, но почему? Вас беспокоят необъяснимые изменения в инфраструктуре, вы боитесь прикасаться к инфраструктуре и коду — в итоге вы задерживаете новый функционал или снижаете качество…

После трёх лет управления на Github коллекцией community-модулей Terraform для AWS и долгосрочном поддержании Terraform в продакшене, Антон Бабенко готов поделиться своим опытом: как писать TF-модули, чтобы не было больно в будущем.

К концу доклада участники будут лучше знакомы с принципами управления ресурсами в Terraform, лучшими практиками, связанными с модулями в Terraform, и некоторыми принципами непрерывной интеграции, связанными с управлением инфраструктурой.

![](https://habrastorage.org/webt/ii/ja/gb/iijagbx-f7undi8xluvpbcwydfe.jpeg)

Меня зовут Антон Бабенко. Кто-то из вас наверняка использовал код, который я писал. Я сейчас буду об этом говорить с большей уверенностью, чем когда-либо, потому что у меня есть доступ к статистике. 

Я занимаюсь Terraform и являюсь активным участником и контрибьютором в большом количестве open source проектов, связанных с Terraform и Amazon с 2015-го года. 

Примерно с тех пор я написал достаточно кода, чтобы изложить это в интересном виде. И об этом я попробую сейчас рассказать.

Я буду рассказывать о тонкостях и о специфике работы с Terraform. Но на самом деле это не является предметом для HighLoad. И сейчас вы поймете почему. 

Со временем я начал писать Terraform-модули. Пользователи писали вопросы, я их переписывал. Потом я написал разные утилиты для форматирования кода с помощью pre-commit hook и т. д.

Было много интересных проектов. Мне нравится заниматься кодогенерированием, потому что я люблю, чтобы компьютер делал все больше и больше работы за меня и за программиста, поэтому сейчас работаю над генератором Terraform-кода из визуальных диаграмм. Возможно, кто-то из вас их видел. Это красивые коробочки со стрелочками. И я считаю, что это здорово, если можно нажать кнопочку «Экспорт» и получить это все как код. 

Я из Украины. Я живу много лет в Норвегии. 

Также информация для этого доклада была собрана от людей, которые знают мое имя и находят меня в социальных сетях. У меня почти всегда один и тот же ник.

![](https://habrastorage.org/webt/ae/uq/qg/aeuqqgdhv8ltpk-fca6yet_yjrs.jpeg)

Как я упомянул, я являюсь главным мейнтейнером Terraform AWS modules, который является одной из самых больших репозиторий на GitHub, где мы хостим модули для самых распространенных задач: VPC, Autoscaling, RDS.

![](https://habrastorage.org/webt/jn/do/ii/jndoii1uc4wxvmid3r0ihprqehg.jpeg)

И то, что вы слышали сейчас, это самое-самое базовое. Если вы сомневаетесь, что вы понимаете, что такое Terraform, то лучше проводить время где-нибудь в другом месте. Здесь будет много технических терминов. И уровень доклада я не постеснялся заявить самым максимальным. Это значит, что я могу рассказывать, используя все-все возможные термины без особого объяснения.   

![](https://habrastorage.org/webt/sn/zj/qo/snzjqopf57sdh3xbg1scjtlglio.jpeg)

Terraform появился в 2014-ом году как утилита, которая позволяла писать, планировать и управлять инфраструктурой как код. Ключевое понятие здесь «инфраструктура как код».

Вся документация, как я сказал, написана на https://www.terraform.io/. Я надеюсь, что большинство знают об этом сайте и прочитали документацию. Если так, то вы в нужном месте. 

![](https://habrastorage.org/webt/xa/ki/cs/xakics1tj4tpdvo6wc_dvwtqujk.jpeg)

Вот так выглядит обычный Terraform-конфигурационный файл, где мы сначала определяем какие-то переменные. 

![](https://habrastorage.org/webt/gb/_u/kh/gb_ukhynarn21ns1qnoschte8hu.jpeg)

В данном случае мы определяем «aws_region». 

![](https://habrastorage.org/webt/gh/zu/kp/ghzukpgiaj-xf6kojy5hhsjgpzg.jpeg)

Потом мы описываем, какие ресурсы мы хотим создать. 

![](https://habrastorage.org/webt/tc/1q/ya/tc1qya9orxxitbh7oayrikjmdec.jpeg)

Запускаем какие-то команды, в частности «terraform init» для того, чтобы загрузить зависимости, провайдеры. 

![](https://habrastorage.org/webt/vy/sc/m-/vyscm-jajj1hzclil8410zgcinq.jpeg)

И запускаем команду «terraform apply» для того, чтобы проверить соответствует ли указанная конфигурация тем ресурсам, которые создали. Т. к. мы ничего не создавали до этого, то Terraform предлагает нам создать эти ресурсы. 

![](https://habrastorage.org/webt/3o/qd/5h/3oqd5hbfgckyehhnn9bsmmg3eyy.jpeg)

Мы подтверждаем это. Таким образом мы создаем bucket, который называется seasnail.

![](https://habrastorage.org/webt/3z/mu/9g/3zmu9gkkebhpmzdjh3x6mnh1aes.jpeg)

Есть также несколько похожих утилит. Многие из вас, кто пользуется Amazon, знают AWS CloudFormation или Google Cloud Deployment Manager, или Azure Resource Manager. У каждого из них есть своя какая-то реализация для управления ресурсами внутри каждого из этих public cloud провайдеров. Terraform особенно полезен в той связи, что он позволяет управлять более 100 провайдерами. (Подробнее на https://www.terraform.io/docs/providers/index.html)

![](https://habrastorage.org/webt/jq/mr/yy/jqmryymoyboylf6ekiwsj6ltswy.jpeg)

Цели, которые преследовал Terraform с самого начала:

- Terraform дает единый вид ресурсов.
- Позволяет поддерживать все современные платформы.  
- И Terraform с самого начала задумывался как утилита, которая позволяет менять инфраструктуру безопасно и предсказуемо.  

В 2014-ом году слово «предсказуемо» звучало очень необычно в данном контексте. 

![](https://habrastorage.org/webt/vb/ca/u0/vbcau0-bgspkimtzfojtkqzzhtm.jpeg)

Terraform является универсальной утилитой. Если у вас есть API, то можно управлять совершенно всем:

- Можно использовать более 120 провайдеров для управления всем, к чему душа лежит.  
- Например, можно использовать Terraform для описания доступа к GitHub репозиториям.  
- Можно даже баги в Jira создавать и закрывать.
- Можно управлять New Relic-метриками.  
- Можно даже файлы в dropbox создавать, если очень хочется.  

Это все достигается с помощью Terraform-провайдеров, у которых открытый API, которые можно описать на Go.

![](https://habrastorage.org/webt/94/kr/ho/94krhouw4glgd-1njpsqbnoefpu.jpeg)

Допустим, мы начали использовать Terraform, прочитали какую-то документацию на сайте, посмотрели какое-то видео, начали писать main.tf, как я показывал на предыдущих слайдах. 

![](https://habrastorage.org/webt/hc/g4/cc/hcg4cc-jwkoz3ol8kqzyqtfn1m8.jpeg)

И у вас все классно, у вас получился файл, который создает VPC.

Если вы хотите создать VPC, то вы указываете примерно вот эти 12 строк. Описываете в каком регионе вы хотите создать, какой cidr_block IP-адресов использовать. И все. 

![](https://habrastorage.org/webt/ic/d_/gw/icd_gwhkkwjkov9hefm-erz_3r4.jpeg)

Естественно, постепенно проект будет расти. 

![](https://habrastorage.org/webt/s2/9d/xk/s29dxk46snpyah4t_cvz8tgfmh4.jpeg)

И вы будете добавлять туда кучу нового всего: ресурсы, источники данных, вы будете интегрироваться с новыми провайдерами, неожиданно вы захотите использовать Terraform для того, чтобы управлять пользователями в вашем GitHub-аккаунте и т. д. Вы можете захотеть использовать разные DNS-провайдеры, скрещивать все подряд. Terraform легко позволяет это делать. 

![](https://habrastorage.org/webt/q4/5m/7k/q45m7k8k9tnoxry0ovijmanlqvg.jpeg)

Рассмотрим следующим пример.

![](https://habrastorage.org/webt/0j/b6/5w/0jb65wcde3cctjb67hvodiu0gum.jpeg)

Вы постепенно добавляете internet_gateway, потому что вы хотите, чтобы ресурсы из вашего VPC имели доступ в интернет. Это хорошая идея. 

![](https://habrastorage.org/webt/kg/rn/mj/kgrnmjfeucslbkuku0_tyyiusee.jpeg)

В итоге получается вот такой main.tf:

![](https://habrastorage.org/webt/ba/qg/ts/baqgtsdzlnlczrph5ykeq9jxbva.jpeg)

Это верхняя часть main.tf.

![](https://habrastorage.org/webt/xb/ez/tr/xbeztr5z2gle8a0edbg523irmcu.jpeg)

Это нижняя часть main.tf.

Потом вы добавляете subnet. К тому моменту, когда вы захотите добавить NAT gateways, routes, routing tables и кучу других subnets, у вас будет не 38 строк, а примерно 200-300 строк.

![](https://habrastorage.org/webt/zy/yn/4g/zyyn4g3ylyabmzplnabehqemveo.jpeg)

Т. е. ваш main.tf файл постепенно растет. И довольно часто люди складывают все в один файл. В main.tf появляется 10-20 Kb. Представьте, что 10-20 Kb – это текстовый контент. И всё со всем связано. С этим работать постепенно становится сложно. 10-20 Kb – это хороший user case, бывает и больше. И не всегда люди считают, что это плохо. 

Как и в обычном программировании, т. е. не инфраструктура как код, мы привыкли использовать кучу разных классов, пакетов, модулей, группировки. Terraform позволяет делать примерно тоже самое.

![](https://habrastorage.org/webt/tb/fa/sb/tbfasbbywrgq_gvagtdrp1oqb0w.jpeg)

- Код растет.  
- Зависимости между ресурсами тоже растут.  

![](https://habrastorage.org/webt/we/xc/pf/wexcpfag3mv2pqbb2syy67vm9d8.jpeg)

И у нас возникает большая-большая нужда. Мы понимаем, что так жить мы дальше не можем. У нас код становится необъятным. 10-20 Kb – это, конечно, не очень необъятный, но это мы говорим только о network stack, т. е. вы добавили только сетевые ресурсы. Мы не говорим еще об Application Load Balancer, deployment ES cluster, Kubernetes и т. д., куда еще легко можно вплести 100 Kb. Если вы все это напишите, то вы очень скоро узнаете, что Terraform предоставляет Terraform-модули.

![](https://habrastorage.org/webt/60/ol/o5/60olo5ubqpfyon0memxzp3axl2q.jpeg)

Terraform-модули – это самодостаточная Terraform-конфигурация, которая управляется как группа. Это все, что надо знать о Terraform-модулях. Они никакие не умные, они не позволяют делать вам какие-то сложные подключения в зависимости от чего-то. Это все ложится на плечи разработчиков. Т. е. это просто какая-то Terraform-конфигурация, которую вы уже написали. И можно просто ее вызывать как группу. 

![](https://habrastorage.org/webt/zd/i7/nf/zdi7nfmycgyzitttjvtzzt7ttfa.jpeg)

Таким образом мы пытаемся понять, как мы будем оптимизировать наши 10-20-30 Kb кода. Мы постепенно понимаем, что надо использовать какие-то модули. 

Первый тип модулей, который встречается, это ресурсные модули. Они не понимают, о чем ваша инфраструктура, о чем ваш бизнес, где и какие условия. Это именно те модули, которые я вместе с open source сообществом администрируем, и которые мы выдвигаем, как самый начальный building blocks для вашей инфраструктуры. 

![](https://habrastorage.org/webt/e9/xj/pu/e9xjpuvhjuvaytd7hxdyltflphw.jpeg)

Пример ресурсного модуля.

![](https://habrastorage.org/webt/sy/sg/ks/sysgksv9ncltagsxxw9qmz5ebk8.jpeg)

Когда мы вызываем ресурсный модуль, мы указываем с какого пути мы должны загрузить его содержимое.

![](https://habrastorage.org/webt/bb/t_/fi/bbt_fildwwaelufyp63cv7rlf7s.jpeg)

Мы указываем какой версии мы хотим загрузить.

![](https://habrastorage.org/webt/rf/jm/_m/rfjm_mqowc0f9alnrrfzfqbrdgm.jpeg)

Мы передаем кучу аргументов туда. И все. Это все, что нам надо знать, когда мы используем этот модуль.  

![](https://habrastorage.org/webt/ee/2o/vc/ee2ovcirujl0gqul263_ejzzqfg.jpeg)

Многие думают, что если использовать последнюю версию, то все будет стабильно. Но нет. Инфраструктура должна быть версионной, мы четко должны ответить, какой версии была задеплоена та или иная компонента. 

![](https://habrastorage.org/webt/rw/cy/5d/rwcy5djzmkauwvgbrjmmwluwntc.jpeg)

Перед вами код, который находится внутри этого модуля. Модуль security-group. Здесь скролл идет до 640-ой строчки. Создание security-croup ресурса в Amazon во всевозможной конфигурации – это очень нетривиальная задача. Недостаточно просто создать security-group и сказать, какие правила ей передавать. Это было бы очень просто. Внутри Amazon есть миллион разных ограничений. Например, если вы используете **VPC endpoint, prefix list, API wix, API fo** и пытается это всё со всем скрестить, то Terraform не позволяет вам это сделать. И Amazon API тоже не позволяет это. Поэтому надо спрятать эту всю страшную логику в модуль и пользователю выдавать код, который выглядит только вот так. 

![](https://habrastorage.org/webt/e9/xj/pu/e9xjpuvhjuvaytd7hxdyltflphw.jpeg)

Пользователю не надо знать, как внутри оно сделано. 

![](https://habrastorage.org/webt/ng/9h/kv/ng9hkvm-dswptfc1dwcv9-elega.jpeg)

Второй тип модулей, который состоит из ресурсных модулей, уже решает задачи, которые более применимы для вашего бизнеса. Часто это место, которое является расширением для Terraform и задает какие-то жесткие значения для тегов, для стандартов компании. Также там можно добавлять функционал, который Terraform не позволяет сейчас использовать. Это именно сейчас. Сейчас версия 0.11, которая вот-вот отойдет в прошлое. Но все равно препроцессоры, jsonnet, cookiecutter и куча других вещей являются тем вспомогательным механизмом, который надо использовать для полноценной работы. 

Дальше я покажу некоторые примеры из этого. 

![](https://habrastorage.org/webt/fd/ia/nj/fdianje604p1docozzx-wpx6vl0.jpeg)

Инфраструктурный модуль вызывается точно таким же способом. 

![](https://habrastorage.org/webt/fs/qg/-k/fsqg-kkzcw6tnh-oe_ixms_d-gc.jpeg)

Указывается источник, откуда загрузить контент.

![](https://habrastorage.org/webt/dh/do/dz/dhdodzoi6mfxisvy8rvxutcxtq8.jpeg)

Передается куча значений, которые передаются в этот модуль. 

![](https://habrastorage.org/webt/-d/g8/5u/-dg85ubcbxxaatueghjnyzeqksq.jpeg)

Далее внутри этого модуля вызывается куча ресурсных модулей для создания VPC или Application Load Balancer, или для создания security-group или для Elastic Container Service кластера.

![](https://habrastorage.org/webt/4b/t4/jg/4bt4jgwk3vyiixg-grlq-awka8a.jpeg)

Есть два типа модулей. Это важно понимать, потому что большинство информации, которую я сгруппировал в этом докладе, не написана в документации. 

И документация в Terraform прямо сейчас достаточно проблематичная, потому что она просто говорит, что есть такие фичи, вы можете их использовать. Но она не говорит, как эти фичи использовать, почему так лучше использовать. Поэтому очень большое количество людей пишут что-то, с чем потом нельзя жить.

![](https://habrastorage.org/webt/ew/cn/1n/ewcn1nrdqgqfj7m3hhsnzv6zqts.jpeg)

Давайте дальше посмотрим, как писать эти модули. Потом посмотрим, как их вызывать и как работать с кодом. 

![](https://habrastorage.org/webt/pr/2j/b3/pr2jb3czf91y1t1vng6ofpaf7bi.jpeg)

Terraform Registry - https://registry.terraform.io/

Совет № 0 – это не писать ресурсные модули. Большинство этих модулей уже написано за вас. Как я говорил, они open source, они не содержат никакой вашей бизнес-логики, в них нет захардкоженных значений для IP-адресов, паролей и т. д. Модуль является очень flexible. И он уже, скорее всего, написан. Для ресурсов от Amazon модулей много. Около 650. И большинство из них хорошего качества. 

![](https://habrastorage.org/webt/kn/qj/fj/knqjfjut6jti5b5etoz6yvffzt4.jpeg)

На данном примере к вам пришел кто-то и сказал: «Я хочу иметь возможность управлять базой данных. Создай модуль, чтобы я мог создавать базу данных». Человек не знает подробностей реализации ни Amazon, ни Terraform. Он просто говорит: «Я хочу управлять MSSQL». Т. е. мы подразумеваем, что он будет вызывать наш модуль, передаст туда тип движка, укажет time-зону.

![](https://habrastorage.org/webt/_6/nz/7f/_6nz7foy542gt9osvj8k3lozhqo.jpeg)

И человек не должен знать, что мы внутри этого модуля будем создавать два разных ресурса: один для MSSQL, второй для всего остального только потому, что в Terraform 0.11 нельзя указывать значения time-зоны необязательным. 

![](https://habrastorage.org/webt/rz/av/kj/rzavkj5to-pnpoiiqrx1byss88q.jpeg)

И на выходе из этого модуля человек будет иметь возможность просто получать адрес. Он не будет знать с какой базы данных, с какого ресурса мы внутри это все создаем. Это очень важный элемент скрытия. И это применимо не только для тех модулей, которые находятся в public в open source, а также для тех модулей, которые вы будете писать внутри своих проектов, команд. 

![](https://habrastorage.org/webt/2l/ef/7-/2lef7-3v4hrjm-oayect6zv3mba.jpeg)


Вот это второй аргумент, который является довольно важным, если вы используете Terraform какое-то время. У вас есть репозиторий, в котором вы складываете все свои Terraform-модули для вашей компании. И вполне нормально, что со временем этот проект вырастет до размера одного-двух мегабайт. Это нормально. 

Но проблема заключается в том, как Terraform вызывает эти модули. Например, если вы будете вызывать модуль для создания каждого индивидуального пользователя, то Terraform сначала будет загружать весь репозиторий, а потом переходить в папку, где находятся конкретно этот модуль. Таким образом вы будете каждый раз загружать по одному мегабайту. Если вы управляете 100 или 200 пользователями, то вы загрузите 100 или 200 мегабайт, а потом уже перейдете в ту папку. Таким образом, естественно, вы не хотите каждый раз, когда нажимаете «Terraform init» загружать кучу всего. 

![](https://habrastorage.org/webt/ie/ol/9g/ieol9gwxs3nadxpouxcd7uujce0.jpeg)

Есть два решения этой проблемы. Первое заключается в том, чтобы использовать относительные пути. Таким образом вы в коде указываете, что папка локальная (./). И перед тем, как что-то запускать, вы делаете Git clone этого репозитория локально. Таким образом вы делаете это один раз. 

Есть, конечно, куча downsides. Например, что нельзя использовать versioning. И с этим иногда сложно жить. 

Второе решение. Если у вас много подмодулей и у вас есть уже какой-то устаканенный pipeline, то есть проект MBT, который позволяет собирать из монорепозитория много разных пакетов и загружать их на S3. Это очень хороший способ. Таким образом файл iam-user-1.0.0.zip будет весить всего лишь 1 Kb, потому что код для создания этого ресурса очень маленький. И это будет намного быстрее работать. 

![](https://habrastorage.org/webt/y2/uw/vy/y2uwvylxkv4ty4vfjc5drnkyh0o.jpeg)

Поговорим о том, что нельзя использовать в модулях. 

![](https://habrastorage.org/webt/g5/8w/o7/g58wo79_b9hchqbyzwu_e8rjknw.jpeg)

Почему в модулях это зло? Самая страшная вещь – это assume user. Assume user – это такой вариант аутентификации в провайдер, который могут использовать разные люди. Например, мы все будем ассюмить роль. Это значит, что Terraform будет принимать эту роль. И потом с этой ролью будет выполнять остальные действия.

![](https://habrastorage.org/webt/jr/fz/43/jrfz43qss3qr7qvtpvd_lijuub0.jpeg)

И зло заключается в том, что если Вася любит подключаться к Amazon одним способом, например, используя по умолчанию переменное окружение, а Петя любит использовать свой shared key, который у него находится в секретном месте, то в Terraform нельзя указывать и то и другое. И для того, чтобы они не испытывали страданий, не надо этот блок указывать в модуле. Это надо указывать уровнем выше. Т. е. у нас есть ресурсный модуль, инфраструктурный модуль и композиция сверху. И где-нибудь повыше это надо указывать. 

![](https://habrastorage.org/webt/fa/vj/mt/favjmtuheebxgdgkcoi_ht9lnqa.jpeg)

Второе зло заключается в provisioner. Здесь зло не настолько тривиальное, потому что если пишите код и для вас он работает, то вы можете подумать, что если он работает, то зачем менять. 

![](https://habrastorage.org/webt/xg/oe/m0/xgoem0divo_4wv3ydyehletcrxe.jpeg)

Зло заключается в том, что этот provisioner вы не всегда контролируете, когда он конкретно будет запускаться, во-первых. И, во-вторых, вы не контролируете, что значит aws ec2, т. е. мы говорим сейчас про Linux или про Windows. Таким образом, вы не можете писать что-то, что будет работать одинаково в разных операционных системах или для разных user cases.

![](https://habrastorage.org/webt/vn/zh/w7/vnzhw7ksll5zdvzvkt469e6cfry.jpeg)

Самый распространенный пример, который в том числе указан в официальной документации, это то, что если вы пишите aws_instance, указываете кучу аргументов, то ничего плохого в этом нет, если вы укажете там и provisioner «local-exec» и запустите свой ansible-playbook.

![](https://habrastorage.org/webt/so/bg/bx/sobgbxaaijp_shkqzzffzg3yh5w.jpeg)

На самом деле – да, ничего плохого в этом нет. Но буквально скоро вы осознаете, что вот эта штука local-exec не существует, например, в launch_configuration. 

![](https://habrastorage.org/webt/qp/do/hy/qpdohy-b5xgyfwm1duf6lbvzawk.jpeg)

И когда вы используете launch_configuration, и вы хотите из одного instance создать autoscaling group, то в launch_configuration нет понятия «provisioner». Там есть понятие «user data».

![](https://habrastorage.org/webt/6n/lf/2z/6nlf2zfha8ilys3fegx1gmbjeuu.jpeg)

Поэтому более универсальным решением является использование user data. И будет запускаться либо на самом instance, когда instance включится, либо в этом же user data, когда autoscaling group будет использовать этот launch_configuration.

![](https://habrastorage.org/webt/z9/qe/ss/z9qesscbuddebiskaywwebjwr2i.jpeg)


Если все-таки есть желание запустить provisioner, потому что он является склеивающим компонентом, когда один ресурс будет создан и в этот момент надо запустить свой provisioner, свою команду. Таких ситуаций очень много. 

И самый правильный ресурс для этого называется null_resource. Null_resource – это фиктивный ресурс, который на самом деле не создается никогда. Он ничего не трогает, нет API, нет autoscaling. Но он позволяет регулировать, когда запускать команду. В данном случае запускается команда во время создания.

![](https://habrastorage.org/webt/c8/h4/pv/c8h4pv7eoiwgut-me5gfvofu2qc.jpeg)

Есть несколько признаков. Я не буду останавливаться на всех признаках очень детально. Есть статья об этом. Но если вы работали с Terraform или использовали чужие модули, то вы часто замечали, что многие модули, как и большую часть кода в open source, люди пишут для своих каких-то нужд. Человек его написал, решил свою задачу. Заколбасил его в GitHub, пускай живет. Он будет жить, но если там нет никакой документации и примеров, то никто им пользоваться не будет. И если там нет функционала, который позволяет решать чуть больше, чем его конкретную задачу, то им тоже никто не будет пользоваться. Есть очень много способов потерять пользователей. 

Если вы хотите написать что-то, чтобы люди этим пользовались, то я рекомендую следовать этим признакам. 

Это:

- Документация и примеры.
- Полный функционал.
- Разумные значения по умолчанию.
- Чистый код.
- Тесты.

Тесты – это отдельная ситуация, потому что их довольно сложно написать. Я больше верю в документацию и в примеры. 

Итак, мы посмотрели, как писать модули. Есть два аргумента. Первый, который наиболее важный, это не пиши, если можешь, т. к. кучу-куча людей уже сделали эти задачи до вас. И второй, если все-таки решился, то провайдеры в модулях и provisioner старайся не использовать. 

Это серая часть документации. Вы можете сейчас подумать: «Что-то непонятно. Не убедил». Но посмотрим через полгода. 

Как вызывать Terraform-модули

Теперь поговорим о том, как вызывать эти модули. 

Мы понимаем, что со временем наш код растет. У нас уже не один файл, у нас уже 20 файлов. Все они лежат в одной папке. Или, может, в пяти папках. Может быть, мы начинаем их как-то разбивать по регионам, по каким-то компонентам. Потом мы понимаем, что теперь у нас какие-то зачатки синхронизации, оркестрации должны возникать. Т. е. должны понять, что нам делать, если мы поменяли сетевые ресурсы, что нам делать с остальными нашими ресурсами, как вызывать эти зависимости и т. д. 

Все в одном






Есть две крайности. Первая крайность – это все в одном. У нас есть один мастер-файл. До поры до времени это был официальная best practice на сайте Terraform.

Но сейчас это написано как deprecated и убрано. Со временем Terraform-сообщество поняло, что это далеко не best practice, потому что люди начинают использовать проект в разных видах. И есть проблемы. Например, когда мы указываем все зависимости в одном месте. Бывает ситуации, когда мы нажимаем «Terraform plan» и пока Terraform обновит состояния всех ресурсов, может пройти куча времени. 

Куча времени – это, например, 5 минут. Для кого-то это куча времени. Я видел случаи, когда это занимало 15 минут. 15 минут AWS API дергался для того, чтобы понять, что со состоянием каждого ресурса. Это очень большая область. 

И, естественно, появится связанная проблема, когда вы захотите поменять что-то в одном месте, потом подождали 15 минут, а оно вам выдало полотно каких-то изменений. Вы плюнули, написали «Yes», и что-то пошло не так. Это вполне реальный пример. Terraform не старается вас отгородить от проблем. Т. е. пишите, что хотите. Будут проблемы – ваши проблемы. Пока Terraform 0.11 не старается вам помочь никак. В 0.12 есть определенные интересные места, которые позволяют вам сказать: «Вася, ты действительно этого хочешь, можешь одумаешься?». 

1-in-1

Второй способ заключается в уменьшение этой области, т. е. можно меньше связывать вызовы одного места из другого места. 

Единственная проблема в том, что нужно писать больше кода, т. е. нужно описывать переменные в большом количестве файлов, обновлять это. Кому-то это не нравится. Для меня это нормально. А некоторые думают: «Зачем это писать в разных местах, я это все в одном месте заколбасю». Можно и так, но это вторая крайность.

А как у вас? «Все в одном» или 1-in-1?

У кого это все живет в одном месте? Один, два, три человека, т. е. кто-то использует. 

А кто вызывает один конкретно компонент, один блок или один инфраструктурный модуль? Человек пять-семь. Это здорово. 

~~Правильный~~ Самый частый ответ: где-то посередине

Самый частый ответ – это где-то посередине. Если проект большой, то у вас часто будет ситуация, когда ни то решение не годится и там не все получается, поэтому у вас получается смесь. В этом ничего плохого нет, лишь бы вы понимали, что есть преимущество и у того, и у того. 

А как у вас с оркестрацией?

Если изменилось что-то в stack VPC и вы захотели применить эти изменения EC2, т. е. вы захотели обновить autoscaling group, потому что у вас появилась новая subnet, то такого рода зависимости я называю оркестрацией. Есть какие-то решения: кто как использует? 

Оркестрация в Terraform

Я могу подсказать, какие есть решения. Можно использовать Terraform для того, чтобы делать магию, а можно использовать make-файлы для использования Terraform. И смотреть, если там что-то поменялось, можно тут запустить. Как вам такое решение? Кто-то верит, что это классное решение? Я вижу улыбку, видать сомнения закрались. 

Не повторяйте это дома!

Конечно, не повторяйте это дома. Terraform никогда не был создан для того, чтобы запускаться из Terraform.

Мне на одном докладе сказали: «Нет, это не будет работать». Дело в том, что оно и не должно работать. Хоть оно и выглядит так эффектно, когда ты можешь из Terraform запустить Terraform, а там еще Terraform, но не надо так делать. Terraform должен всегда запускаться очень просто. Если у вас есть нужна в оркестрации вызовов, когда поменялось что-то в одном месте, то есть Terragrunt.

Оркестрация = Terragrunt

Terragrunt – это утилита, это надстройка над Terraform, которая позволяет координировать и оркестрировать вызовы инфраструктурных модулей.

Типичный Terraform-конфигурационный файл выглядит вот так. Вы указываете, какой конкретно модуль вы хотите вызвать, какие у модуля есть зависимости и какие аргументы этот модуль принимает. Это все, что нужно знать о Terragrunt.

Документация там есть, 1 700 звездочек на GitHub тоже есть. Но в большинстве случаев это то, что надо знать. И это очень легко вживить в компании, которые только начали работать с Terraform.

Таким образом, оркестрация – это Terragrunt. Другие варианты есть. 

Теперь давайте поговорим, как работать с кодом. 

Новый или существующий

Если у вас есть необходимость добавить новые фичи в код в большинстве случаев это легко. Вы пишите новый ресурс, тут все просто. 

Если у вас есть какой-то ресурс, который вы создали заранее, например, вы про Terraform узнали после того, как вы открыли AWS-аккаунт и хотите использовать те ресурсы, которые у вас уже есть, то будет уместно расширить свой модуль таким образом, чтобы он поддерживал использование существующих ресурсов и поддерживал создание новых ресурсов, используя ресурс block. На выходе мы всегда возвращаем output id в зависимости оттого, что было использовано.

Работа со списками

Вторая очень существенная проблема в Terraform 0.11 – это работа со списками. Сложность заключается в том, что если мы имеем такой список users, и когда мы создаем этих users, используя block resource, то все проходит нормально. Мы проходим по всему списку, создаем каждому файлик. Все нормально. И потом, например, user3, который по середине, должен быть убран отсюда, то все ресурсы, которые были созданы после него, они будут пересоздаваться, потому что индекс изменится. 

Работа со списками

Работа со списками в stateful-окружении. Что такое stateful-окружение? Это та ситуация, когда возникает новое значение при создании этого ресурса. Например, AWS Access Key или AWS Secret Key, т. е. когда мы создаем user’а, нам приходит новый Access или Secret Key. И каждый раз, когда мы будем удалять какого-то user’а, у этого user’а будет новый ключ. Но это не по фэншуй, потому что user не захочет с нами дружить, если мы будем каждый раз создавать нового user’а для него, когда кто-то покидает команду.

Решение такое. Это код, написанный на Jsonnet. Jsonnet – Это язык создания шаблонов от Google. Это команда позволяет принять этот шаблон и на выходе он возвращает json-файл, который сделан по вашему шаблону. Шаблон выглядит вот так. 

Terraform позволяет работать и с …, и с Json одинаково, поэтому если у вас есть возможность генерировать Json, то вы можете его подсунуть в Terraform. Файл с расширением .tf.json будет успешно загружен. 

И потом мы работаем с этим как обычно: terraform init, terramorm apply. И мы создаем двух user’ов.

Теперь нам не страшно, если кто-то покинет команду. Мы просто отредактируем json-файл. Вася Пупкин ушел, Петя Пяточкин остался. Петя Пяточкин не получит новый ключ. 

Интеграция

Интеграция Terraform с другими средствами, по сути, не является задачей Terraform. Terraform создавался как платформа для создания ресурсов и все. И все, что подходит потом – это не забота Terraform. И не надо туда вплетать его. Есть Ansible Tasker, который делает все, что надо. 

Но возникают ситуации, когда мы хотим дополнить Terraform и вызвать какую-то команду после того, как что-то выполнилось. 

Первый способ. Мы создаем output, где мы пишем эту команду, а потом эту команду вызываем из shell terraform output и указываем это значение, которое мы хотим. Таким образом исполняется команда со всеми подставленными значениями. Это очень удобно. 

Интеграция - авто

Второй способ. Это использование null_resource в зависимости от изменений в нашей инфраструктуре. Мы можем вызывать тот же local-exeс, как только изменится ID какого-то ресурса. 

Гладко было на бумаге (edge cases)

Естественно, это все гладко на бумаге, потому что Amazon как и все остальные public-провайдеры имеет кучу своих edge cases.

Самый распространенный edge cases заключается в том, что, когда вы открыли AWS-аккаунт, важно, какие вы регионы используете; включена ли эта фича там; может быть, вы его открыли после декабря 2013-го года; может быть, вы используете дефолт в VPC и т. д. Есть много ограничений. И Amazon разбросал их по всей документации.

Избегай в Terraform

Есть несколько вещей, которые я рекомендую избегать.

Для начала избегайте всех несекретных аргументов внутри Terraform plan или Terraform CLI. Все это можно сложить либо в tfvars-файл, либо в переменное окружение. 

Но не надо запоминать всю эту магическую команду. Terraform plan – var и понеслась. Первая переменная – var, вторая переменная – var, третья, четвертая. Самый важный принцип инфраструктуры как код, который я чаще всего использую, это то, что, просто взглянув на код, я должен прекрасно понимать, что там задеплоено, в каком состоянии и с какими значениями. И поэтому мне не надо читать документацию или спрашивать Васю о том, какие параметры он использовал для создания нашего кластера. Мне достаточно открыть файл с расширением tfvars, который часто совпадает с окружением, и посмотреть все там.

Также не надо использовать аргументы target для уменьшения области действия. Для этого намного проще использовать маленькие инфраструктурные модули. 

Также не надо ограничивать и увеличивать parallelism. Если у меня 150 ресурсов и я хочу увеличить parallelism Amazon с 10, которые по умолчанию, до 100, то, скорее всего, что-то пойдет не так. Или может пойти хорошо сейчас, но, когда Amazon скажет, что вы слишком много делаете вызовов, у вас посыплются проблемы. 

Terraform большинство этих проблем будет пытаться перезапустить, но вы не добьетесь почти ничего. Parallelism=1 – это важная вещь, которую надо использовать, если вы споткнулись об какой-то баг внутри AWS API или внутри Terraform-провайдера. И тогда надо указать: parallelism=1 и ждать, пока Terraform закончит один вызов, потом второй, потом третий. По очереди он их будет запускать.

Часто меня спрашивают: «Почему я считаю, что Terraform workspaces – это зло?». Я верю, что принцип инфраструктуры как код заключается в том, чтобы видеть, какая инфраструктура была создана и с какими значениями. 

Workspaces было создано не со стороны пользователей. Это не значит, что пользователи написали в GitHub issues, что жить не можем без Terraform workspaces. Нет, не так. Terraform Enterprise – это коммерческое решение. Terraform от HashiCorp решило, что нам надо workspaces, поэтому мы это запилим.  Я считаю, что намного проще это положить в отдельную папку. Тогда будет чуть больше файлов, но будет понятней.

Как работать с кодом? По сути, работа со списками – единственная боль. И воспринимайте Terraform проще. Это не та вещь, которая будет вам делать все классно. Не надо пихать туда все, что написано в документации. 

В теме доклада было написано «на будущее». Я очень кратко об этом скажу. На будущее – это значит, что скоро выйдет 0.12. 

Terraform 0.12

0.12 – это куча всего нового. Если вы пришли из обычного программирования, то вы скучаете по всяким динамическим блокам, циклам, по правильным и условным операциям сравнения, где левая и правая часть вычисляются не одновременно, а в зависимости от ситуации. Вы очень сильно по этому скучаете, поэтому 0.12 вам решит это. 

Итоги

Но! Если вы будете писать меньше и проще, используя готовые модули, сторонние решения, то вам не надо будет ждать и надеяться, что 0.12 придет и все за вас починит. 

Вопросы

*Спасибо за доклад! Ты говорил об инфраструктуре как код и про тесты сказал буквально одно слово. Нужны ли тесты в модулях? Чья это ответственность? Нужно самому писать или это ответственность модулей?*

Следующий год будет засыпан докладами о том, что мы решили все тестировать. Что тестировать – это самый большой вопрос. Есть куча зависимостей, куча ограничений разных провайдеров. Когда мы с тобой разговариваем, и ты говоришь: «Мне нужны тесты», то я спрашиваю: «Что ты будешь тестировать?». Ты говоришь, что будешь тестировать в своем регионе. Тогда я говорю, что в моем регионе это не работает. Т. е. мы даже на этом с тобой не сможем договориться. Не говоря уже о том, что есть куча технических проблем. Т. е. как написать эти тесты, чтобы они были адекватными. 

Я исследую эту тему активно, т. е. как автоматически генерировать тесты на основании той инфраструктуры, которую ты написал. Т. е. если ты написал этот код, то мне надо его запустить, на основании этого я смогу создать тесты. 

Terratest – это одна из самых часто упоминаемых библиотек, которая позволяет писать тесты интеграционные для Terraform. Это одна из утилит. Мне больше нравится тип DSL, например, inspect … .

*Антон, спасибо за доклад! Меня зовут Валерий. Позволю себя немножко философский вопрос. Есть, условно,* *provisioning**, есть* *deployment**.* *Provisioning* *мою инфраструктуру создает, в* *deployment* *мы ее чем-то наливаем полезным, например, серверами, приложениями и т. д. И у меня в голове сидит, что* *Terraform* *больше для* *provisioning**, а* *Ansible* *больше для* *deployment**, потому что* *Ansible* *и на физическую инфраструктуру позволяет поставить* *nginx**,* *Postgres**. Но при этом и* *Ansible* *вроде бы позволяет сделать* *provisioning**, например, амазонских или гугловых ресурсов. Но и* *Terraform* *позволяет с помощью своих модулей задеплоить какой-то софт. С твоей точки зрения, есть ли какая-то граница, которая проходит между* *Terraform* *и* *Ansible**, где и что лучше использовать? Или, например, ты думаешь, что* *Ansible* *– это уже фигня, надо пытаться* *Terraform* *для всего использовать?*

Хороший вопрос, Валерий. Я считаю, что Terraform с 2014-го года не изменился в плане предназначения. Он создан для инфраструктуры и умер для инфраструктуры. У нас по-прежнему была и будет нужда в configuration management Ansible. Вызов в том, что там есть user data внутри launch_configuration. И там ты дергаешь Ansible и т. д. Вот это стандартное разграничение, которое мне больше всего нравится. 

Если мы говорим про in beautiful infrastructure, то есть утилиты типа Packer, которая собирает этот образ. И дальше Terraform использует data source для поиска этого образа и обновления своей launch_configuration. Т. е. таким образом pipeline заключается в том, что мы дергаем сначала Tracker, потом дергаем Terraform. И если произошел build, то происходит новое изменение. 

*Здравствуйте! Спасибо за доклад! Меня зовут Миша, компания* *RBS**. Можно* *Ansible* *вызывать через* *provisioner* *при создании ресурса. А также в* *Ansible* *есть такая тема, как динамический инвентарь. И можно сначала вызвать* *Terraform**, а потом вызвать* *Ansible**, который из* *state* *возьмет ресурсы и выполнит. Что лучше?*

И то и то люди используют с одинаковым успехом. Мне кажется, что динамический инвентарь в Ansible – это удобная вещь, если мы не говорим про autoscaling group. Потому что в autoscaling group у нас есть уже свой инструментарий, который называется launch_configuration. Мы в launch_configuration записываем все, что надо запускать, когда создаем новый ресурс. Поэтому с Amazon использовать динамический инвентарь и читать Terraform ts файл, по-моему, это излишнее. А если вы используете другие средства, где нет понятия «autoscaling group», например, вы используете DigitalOcean или какой-то другой провайдер, где нет autoscaling group, то там вам надо будет ручками дергать API, находить IP-адреса, формировать dynamic inventory файл, и Ansible будет уже по нему бродить. Т. е. для Amazon есть launch_configuration, а для всего остального есть dynamic inventory.

![](https://habrastorage.org/webt/nk/dw/w6/nkdww643y_vuwqoqhps0clwhagu.jpeg)

![](https://habrastorage.org/webt/qm/fd/ji/qmfdji8-e4kfz34fyg8qhisxgmo.jpeg)

![](https://habrastorage.org/webt/0j/q0/ld/0jq0ld8hoynv-pmfk-omdgfdtzm.jpeg)

![](https://habrastorage.org/webt/b6/3x/wy/b63xwy6voucginof_r4dzjr0mzu.jpeg)

![](https://habrastorage.org/webt/zn/ag/e4/znage4dxnwwzj1xzulmwe8p8qxs.jpeg)

![](https://habrastorage.org/webt/l5/zm/91/l5zm91fcgzbe-tqpn33nfrt7z3y.jpeg)

![](https://habrastorage.org/webt/gm/iw/kz/gmiwkzfrx95ol9cxz9_4ww_toyi.jpeg)

![](https://habrastorage.org/webt/sr/-k/mx/sr-kmxnmb4zz1mlv4kqhpqv8ryg.jpeg)

![](https://habrastorage.org/webt/va/pc/m5/vapcm5d_yfdcoe-92vdo_9edzrc.jpeg)

![](https://habrastorage.org/webt/p-/q0/eh/p-q0ehfr7isrtjsqcfduwbqdcwq.jpeg)

![](https://habrastorage.org/webt/k-/vn/tq/k-vntqigsuuxbbodrj4xs9cdt14.jpeg)

![](https://habrastorage.org/webt/rw/hg/ux/rwhguxr-lveylz6ajruf_hzoifg.jpeg)

![](https://habrastorage.org/webt/cz/ak/zh/czakzhlfb91mnivtw-ooy5l_shk.jpeg)

![](https://habrastorage.org/webt/6z/pn/fm/6zpnfmbzbpynmksedmikhvd7d5q.jpeg)

![](https://habrastorage.org/webt/kb/ip/lr/kbiplrk5axpgvd19ijp88lpdhvg.jpeg)

![](https://habrastorage.org/webt/gh/fo/vv/ghfovvigpdzuyd06w92k7uz7tlo.jpeg)

![](https://habrastorage.org/webt/zk/4u/ed/zk4uedcbybb3n6dlp73wq9sbofw.jpeg)

![](https://habrastorage.org/webt/af/ie/mf/afiemfnpzj5gttdhkhyr0duadmi.jpeg)

![](https://habrastorage.org/webt/_i/6i/t1/_i6it1xinm2pfkaaegcfkjlva5k.jpeg)

![](https://habrastorage.org/webt/wd/ri/v6/wdriv6pk31ivybitqhozrw1yocm.jpeg)

![](https://habrastorage.org/webt/82/t-/by/82t-byxcxv9u43yupotfl38fdtm.jpeg)

![](https://habrastorage.org/webt/ql/xv/8t/qlxv8tp2ghpdp4fkjqkxtlpgda0.jpeg)

![](https://habrastorage.org/webt/3q/zi/gk/3qzigkjz6ribbuioz8shmfuiddq.jpeg)

![](https://habrastorage.org/webt/3f/jb/vh/3fjbvhgo2uo67gxejcw6tkcl1ww.jpeg)

![](https://habrastorage.org/webt/hf/nl/bs/hfnlbsliqglglp8_nwxcsmoes84.jpeg)

![](https://habrastorage.org/webt/4z/ro/wd/4zrowd8rzfwcdhoxr6wwdaftto8.jpeg)

![](https://habrastorage.org/webt/gi/yy/qo/giyyqovsjm8c2pxkjj-rrkxbj_4.jpeg)

![](https://habrastorage.org/webt/e8/gl/qz/e8glqzllxtx97l3_0skunymdpri.jpeg)

![](https://habrastorage.org/webt/j7/1f/pi/j71fpiuhigyvfyyis0tctlbzsgy.jpeg)

![](https://habrastorage.org/webt/jn/3o/sl/jn3oslg36mjm9hgr8u9wmnp6yxe.jpeg)

![](https://habrastorage.org/webt/me/m9/pe/mem9pe2ke-x90lqy-n0lw-4zrba.jpeg)

![](https://habrastorage.org/webt/qu/ex/mb/quexmb8nhigodzmejigizel3ufk.jpeg)

![](https://habrastorage.org/webt/ac/zm/do/aczmdo_wyfqi_njlucu-cm9uesy.jpeg)

![](https://habrastorage.org/webt/sx/gr/no/sxgrnogyuys-mjd2up1glbep3si.jpeg)

![](https://habrastorage.org/webt/ey/ig/py/eyigpyvvs01x8s3imrqc0cyr6im.jpeg)

![](https://habrastorage.org/webt/jz/xz/js/jzxzjspp_ndksax0j756tsereto.jpeg)

![](https://habrastorage.org/webt/qt/9v/0m/qt9v0mkozluq5mjqqm-skz0w7ho.jpeg)

![](https://habrastorage.org/webt/zy/tl/ty/zytlty2cmm6pmdgb_uypeikg-my.jpeg)

![](https://habrastorage.org/webt/v3/mm/8g/v3mm8gxh0nh7swjkgbvyjclpips.jpeg)