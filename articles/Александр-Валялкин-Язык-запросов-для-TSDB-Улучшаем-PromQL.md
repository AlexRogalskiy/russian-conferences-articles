**Язык запросов для TSDB. Улучшаем PromQL (Александр Валялкин, VictoriaMetrics)**

Добрый день! Сегодня я вам расскажу немножко про PromQL. Это язык запросов для time-series баз данных. И потом расскажу, как его мы улучшили в системе, которую я разрабатываю в time-series баз данных VictoriaMetrics.

Что такое PromQL?

Это язык запросов, который используется в Prometheus системе. 

Чем отличается от других альтернативных запросов для time-series баз данных таких, как SQL, InfluxQL или Flux, или от языка запросов, который используется в Graphite? Можно привести много примеров. Многие time-series базы данных используют свои собственные языки запросов. И я считаю, что PromQL – это один из лучших языков запросов для time-series баз данных, потому что он лаконичный и позволяет решать большинство задач, стоящих перед разработчиками, которые хотят получить какие-то данные из time-series баз данных. 

Пример SQL запроса (привет, TimescaleDB)

Рассмотрим пример SQL запроса, типичного для выборки time-series данных. 

Что делает этот запрос? Мы выбираем все метрики с именем вот таким. И выбираем для всех этих метрик все их имена, все timestamps и все значения. Как видите, запрос очень простой. Он состоит из подзапроса, состоит еще из одного подзапроса и из JOIN.

Тот же запрос в PromQL

Теперь посмотрим, как он выглядит на PromQL. Вот этот же запрос в PromQL языке программирования. 

И PromQL позволяет строить красивые графики в Grafana. Наверное, тут ничего не видно. Там какая-то штука написана. Этот запрос завернут в rate, потому что этот запрос оканчивается на total. И эта метрика, которая является counter, и она возвращает значение, которое постоянно растет. Если я бы его просто вывел на этом графике, то мы бы увидели тут постоянно растущий вверх график. Чтобы вывести скорость изменения этого графика, применяем функцию rate и получаем такие графики, где видна скорость получения данных по сети. 

Недостатки PromQL

Но у PromQL есть еще недостатки по сравнению с SQL.

Ограниченная функционально по сравнению с SQL

У него ограничена функциональность, т. е. на SQL можно сделать то, что нельзя сделать на PromQL. SQL более мощный язык. 

- Например, в SQL можно в SELECT вставить все, что хочешь, а в PromQL туда можно вставить аналог SELECT. Это выборки только value значения. Там даже нельзя делать операции с timestamps.  
- В PromQL ограниченный JOIN.  
- Нет нормального GROUP BY. Есть аналог, он делает группировку по временным рядам.  
- Нет сортировки. Есть стандартная сортировка только по времени.  
- Нет HAVING.  
- И нет еще других фич, которые есть в SQL.

Но всем пофиг, кто работает с time-series базами данных. Потому что SQL мощный язык, но для time-series он не очень походит. 

Data model в голове e Brian Brazil 

Следующий недостаток у PromQL – это data model в голове главного разработчика Prometheus и языка программирования PromQL. Его зовут Brian Brazil.

Из-за этой модели, которая у него в голове, и которую он не хочет никак изменять, существуют баги, которые Brain считает не багами, а фичами.

- Первая бага-фича – это то, что PromQL возвращает пустой график. Step интервал – это расстояние между соседними точками на графике. И если оно будет меньше, чем scrape_interval, а scrape_interval – это интервал между реальными точками, которые хранятся в базе данных. Если он становится меньше, то мы в итоге получаем пустой график.  
- Вторая бага-фича – это то, что функция increase, которая возвращает разницу между точками во временном ряду, может возвращать дробное значение, даже если во временном ряду хранятся у вас … значения. Например, метрика поменялась на 10-ку, а increase вам вернет 9,5. Это из-за интерполяции, которая соответствует data model в голове Brian Brazil.  
- Также можно принести к недостаткам PromQL то, что у него нет функции для вычисления min/ max значения для rate. Rate – это функция, которая возвращает скорость изменения метрики. Т. е. rate возвращает среднюю скорость изменения метрики, но не возвращает ни максимального, ни минимального значения.  
- И в rate нужно указывать в квадратных скобках d значение. Это расстояние от текущей точки, для которой рисуется график, до точки в прошлом, на основе которых на этом расстоянии вычисляется rate. И для тех, кто только начинает пользоваться этим PromQL, это не совсем удобно. В том числе и я был начинающим пользователем, и я не понимал назначение этих квадратных скобок, и часто пропускал их, и не понимал, почему мои графики не показываются, и Prometheus ругается на мои функции.  

Недостаток PromQL + Grafana

Также к недостаткам PromQL можно отнести то, что в связке с Grafana, когда в Grafana рисуются дашборды, в запросах часто приходится повторять один и тот же набор фильтров. 

Вот пример стандартного фильтра, который встречается в большинстве дашбордов в Grafana. И он должен повторяться в каждом запросе.

Как улучшить PromQL?

И как решить эти проблемы?

VictoriaMetrics

Та-там – VictoriaMetrics. Это система time-series баз данных, которую разрабатывал я и мои коллеги. 

Что такое VictoriaMetrics?

- Это time-series база, которая может работать как long-term remote storage для Prometheus, т. е. может хранить данные из Prometheus.  
- Может принимать данные в форматах не только Prometheus, но и Influx, OpenTSDB и Graphite.  
- VictoriaMetrics понимает PromQL, в нее встроен движок PromQL.
- И VictoriaMetrics улучшает PromQL. Она решает все проблемы, которые были на предыдущем слайде. И дальше мы рассмотрим несколько таких примеров.  

Можно пропускать квадратные скобки

Первый пример – убираем квадратные скобки в rate.

Вот такой запрос promql’ский можно записать в таком виде в VictoriaMetrics. VictoriaMetrics понимает весь стандартный PromQL, но можно сократить.

Что тут происходит? В квадратных скобках мы пишем такой интервал. Grafana вместо этой переменной вставляет туда интервал между соседними точками, которые она рисует на графике. И иногда пользователи приходят к вот такому решению, когда указывают интервал в квадратных скобках. И если они перейдут на VictoriaMetrics, то им необязательно этот интервал указывать. Можно написать rate без квадратных скобок, это будет аналогично работать. 

Можно ссылаться на $_interval в квадратных скобках

Следующий пример. Мы можем в квадратных скобках указывать множитель для этого интервала. Например, вот такой гипотетический запрос, где интервал умножается на 5. Это означает, что для каждой точки мы будем вычислять значение на 5 последних интервалах. В PromQL можно изменить на вот такой запрос. 

Можно использовать $_interval в вычислениях

Следующий пример. Мы можем этот интервал использовать в вычислениях, т. е. указывать не только в квадратных скобках, но и в самом запросе. Например, в PromQL есть такая функция «deriv», которая вычисляет производную. 

Что такое производная? Вот написано, как вычислять производную с помощью расширенного PromQL в VictoriaMetrics. Мы берем значение метрики. Отнимаем от него значение метрики, которое было на 5 интервалах назад, и делим на длину этого интервала, состоящий из 5 интервалов. Step функция возвращает длину интервала в секунду. Получаем производную. 

Поддержка $_interval < scrape_interval

В VictoriaMetrics решена проблема бага-фича, где в запросе указывается интервал, который меньше, чем расстояние между соседними точками в базе данных. Как вы помните, Prometheus в этом случае возвратит пустой график, VictoriaMetrics возвратит нормальный график благодаря своему алгоритму. 

Какой алгоритм? Prometheus для вычисления графика rate нужно, чтобы на каждом интервале было минимум две точки. И если там будет меньше, чем две точки, то Prometheus вернет пустой график. А VictoriaMetrics смотрит, если на данном интервале нет ни одной точки, то она берет предыдущие пару точек, но при условии, если находятся не дальше, чем двойной scrape_interval на данном time-series для того, чтобы не рисовать график там, где его недолжно быть. Таким образам получаем такой график. Тут у нас интервал указан в 0,1 секунду. Видно на графике, что между вертикальными линиями 1 секунда и график нормально рисуется, все отлично, хотя scrape_interval, т. е. расстояние между точками, которые хранятся в Prometheus, составляет, по-моему, 10 секунд. 

Rollup_* функции

Также в VictoriaMetrics добавлены rollup функции, которые возвращают одновременно три значения. Это минимальное, максимальное и среднее значения. Это позволяет наглядно видеть границы вашей метрики и не терять информацию при зуме в графиках. 

VictoriaMetrics поддерживает несколько rollup функций такие, как просто rollup. Это функция для метрик, которые могут меняться во времени произвольным образом. 

И поддерживает функцию rollup_rate. Это аналог rate. Это функция для counters, еще есть другие функции, которые иногда могут пригодиться. 

Rollup_rate

Это пример применения rollup_rate к метрике. Как мы видим возвращаются у нас три линии, три значения. Максимальное значение для каждой точки, построенной на графике, а также среднее значение и минимальное. 

Если на этом графике построить просто rate для такой же величины, то мы бы увидели только вот этот средний график. Как мы видим, что у нас максимальное значение намного превышает среднее. И есть еще минимальное. И если мы это будем зумить, будет выбирать график за больший промежуток времени, либо меньший, то мы не будем терять информацию о максимальном и минимальном значениях в отличие от rate, где при зуме в большую сторону, то у нас rate берет среднее значение по этому интервалу.

Range_* функции – подсчет глобального значения на всем графике

В VictoriaMetrics есть также функция range, которая иногда бывает полезной. Она вычисляет глобальное значение по всему отображаемому графику, который вы запросите. 

Есть минимальное, максимальное, среднее значение, а также quantile, sum, первое значение, последние значение. 

Range_avg: вычисляем отклонение от среднего

Где он может быть полезен? Например, вычислить отклонение от среднего. Вот там какой-то rate вычисляется. И мы от него отнимаем тоже rate и заворачиваем его просто в range. И получаем такой график, где видно, что он колеблется около нуля.

Оператор default

Есть еще оператор default, который заменяет пропуски в графиках значениями, которые указаны справа от default.

Например. На данном графике у нас какой-то sinus. И график без дефолта показывал бы только значение sinus, который больше, чем 0,3. Он бы показывал вот такие выступы sinus. А мы пишем дефолт и указываем rand, т. е. случайное значение. И видим, что там, где у нас были бы пропуски графика, есть рандомное значение. Вместо rand обычно пишут дефолт 0, чтобы заполнить пропуски графика. 

Управление label’ами

Также есть более удобное управление label’ами. Стандартный PromQL поддерживает управление label’ами. Там есть две функции: label_replace и label_j…, которую сложно использовать и постоянно нужно смотреть документацию, чтобы знать, какие аргументы что означают. 

И в PromQL я решил добавить функции, которые более простые для управления label’ами: 

- Label_set – позволяет устанавливать произвольно labels на time-series. Устанавливает label со значением bar во все временные ряды query.
- Label_del – для удаления произвольных labels из query.  
- Label_keep – удаляет все labels, кроме тех, которые перечислены в функцию.  
- Label_copy и label_move – копирует и меняет label.

WITH templates

В PromQL есть еще такая фича, которая позволяет упрощать сложные PromQL-запросы, где есть много повторений, которые занимают много строчек кода. Это WITH templates. Это аналог common table expressions – CTE. И эту штуку можно попробовать вот здесь.

WITH templates: убираем повторяющиеся фильтры

Самый простой пример – убираем повторяющиеся фильтры. Вот у нас есть PromQL-запрос. Как мы видим, в нем повторяются фильтры {instance=~”$node:$port”, job=~”$job”} в одном, во втором и третьем. 

И с помощью WITH templates это можно заменить вот на такой запрос. В нем прописано with (cf = {instance=~”$node:$port”, job=~”$job”}). Cf – это название WITH templates, который будет потом использоваться у нас дальше. Дальше указываем фильтры, которые везде повторяются. И потом прописываем вот эти метрики, вместо повторяющихся фильтров пишем cf.

WITH templates: функции

Следующий пример – WITH templates поддерживает функции. Вот у нас есть функция ru, которая принимает три аргумента: free, limit, filters. И вычисляет вот такую штуку. 

Ru – это resource usage.

Free – это количество ресурсов, которое у нас доступно еще. 

Limit – это максимальное количество ресурсов.

Filters – это фильтры, которые применяются этим ресурсом. 

И видно, что эта формула будет возвращать использование resource usage и resource utilization, т. е. это процент использования ваших ресурсов. 

И в WITH мы прописываем эту функцию, потом ее используем. И передаем туда эти метрики из node exporter с таким фильтром для labels. И такая функция вернет нам процент оперативной памяти. Вместо метрик для оперативной памяти сюда можно подставлять произвольные метрики, например, использования дискового пространства, использования сети. И получается у вас resource usage.

WITH templates: сложный пример

Вот более сложный пример. В WITH templates можно прописывать сколько угодно templates. У нас тут прописано три templates. CpuSeconds меняется вот на такую штуку. CpuCount меняется на такую штуку. И cpuIdle на такую штуку. И потом мы передаем функцию ru, про которую было рассказано. И получаем процент использования процессора в системе. 

И функция ru уже добавлена в PromQL в VictoriaMetrics, т. е. не надо прописывать WITH такую штуку. Можно сразу писать ru.

Первый параметр – это количество ресурсов, которые еще не использованы. И второй параметр – это максимальное количество ресурсов. И она вернет вам процент использования ресурсов. 

Другие улучшения PromQL

Мы рассмотрели только небольшую часть улучшений, которые есть в VictoriaMetrics. Там есть еще куча других улучшений, которые кому-то могут понадобиться, а кому-то могут показаться бесполезными. Но они туда добавлялись постепенно в тот момент, когда они нам требовались для наших нужд, либо для нужд наших клиентов. 

Вот несколько улучшений таких штук. 

- Это операторы if, ifnot.  
- Дробные указывать интервалы в отличие от PromQL: rate(q[1.5m]) offset 0.5d. В FromQL только целые числа можно указывать.  
- Функции start и end там есть, которые возвращают первое и последнее значение времени на рисуемом графике.  
- Есть функция smooth_exponential, которая сглаживает график.
- И есть куча других функций, советую вам пройтись по этой ссылке и почитать, что там есть еще.  

Мы закончили с расширенным PromQL и сейчас мы рассмотрим такую штуку, как template meta-variables для Grafana.

Bonus: template meta-variables для Grafana

Как вы знаете в Grafana есть template variables. Можно в дашборде установить много произвольных template variables и потом их использовать в каждом графике на этом дашборде. И потом сверху появляются в Grafana меню, где можно выбирать значения для каждого variables. И, соответственно, будут обновляться ваши все графики. 

И как мы уже смотрели ранее, недостаток PromQL в связке с Grafana в том, что для таких дашбордов нам приходится часто повторять одни и те же фильтры для template variables. И если вы собираетесь менять ваш дашборд, то большая вероятность, что вы где-нибудь забудете что-то скопировать, либо изменить и у вас графики с течением времени станут показывать не то, что вы хотели. 

И template meta_variables решает эту проблему. Когда думали о том, как добавить в WITH templates эти variables в Grafana, чтобы сделать удобнее, то решили первым сделать template meta-variables, которые будут полезны для всех пользователей Grafana.

Вот есть issue для этого и наш PR. Мы создали issue, создали PR. И только разработчики Grafana до сих пор не могут рассмотреть этот PR. Так что советуюсь пройтись по нему, поставить лайки, прокомментировать и спросить: «Когда вы ее замержите?».

Template meta-variables для Grafana

Вот что позволяет делать template meta-variables. Мы прописываем новую variables, которая называется commonFilters. И указывает вот такое значение, где упоминаются другие variables: job, instance.

И тогда, где у нас повторяются эти фильтры, мы можем заменить такой запрос на вот такой запрос. Почти как WITH templates, только без WITH templates, т. е. это будет работать даже со стандартным Prometheus.

На этом слайде написано то, что я уже вам говорил. 

- Типичный дашборд содержит десятки запросов с повторяющими фильтрами.  
- Template meta-variables позволяет заменить все эти повторяющиеся фильтры одним meta-variables.  
- Это позволяет быстро редактировать. Мы используем один фильтр вместо того, чтобы править каждый отдельный запрос на дашборде.  
- Template meta-vars полезны не только для Prometheus, но и для любого datasource в Grafana.  

Скоро открытие исходников VictoriaMetrics

Сейчас VictoriaMetrics пока с закрытыми исходниками, но на следующей неделе собираемся открывать исходники. Будут открыты исходники как single-node версии, так и кластерной версии. И я считаю, что это очень знаковое событие, т. к. сейчас нет time-series баз данных с открытыми исходниками, у которых есть нормальная кластерная версия. На следующей неделе в open source можете использовать бесплатно. 

Вопросы?

*Можно ли использовать* *WITH* *templates* *в глобальной области видимости для одного дашборда или для нескольких дашбордов в* *Grafana**?*

Мы планируем так сделать. И мы думаем над этим. Первым шаг – это разработка template meta-variables, которая не зависит от WITH templates и будет работать везде. 

*Александр, а что будет происходить, когда мы льем данные из разных источников? У нас с одной стороны* *InfluxQL**, с другой стороны* *Graphite**, выборки все равно* *Prom**’вые?*

Да, данные можно лить с разных источников по разным протоколам. А запрашивать данные пока можно с PromQL, пока мы не собираемся добавлять дополнительно язык запросов. В будущем, может быть, что-нибудь добавим, но пока все данные запрашиваем с помощью PromQL.

*Т. е. я нафигачил туда данных из* *Graphite**, а потом как я к ним обращусь? Они как-то нормализуются?*

Все time-series данные, которые VictoriaMetrics поддерживает, они имеют регулярную структуру, т. е. у них есть matric name и теги, и value.

*Но в* *Graphite* *нет тегов.*

В Graphite есть теги.

*В* *Graphite* *недавно есть теги.* 

И VictoriaMetrics поддерживает теги графитовские. Т. е. она с тегами работает и без них. 

*Т. е. она не будет интеллектуально как-то конвертировать все это дело?*

Нет. То, что в Graphite без тегов, у в нас есть metric name, он у нас попадет как metric name вместе с точками этими в VictoriaMetrics, т. е. нет никаких конвертаций. Т. е. конвертации небольшие есть с InfluxDB, потому что там немного странный протокол. Там есть теги и филды. И имена филдов преобразуется в metric names. А теги так и добавляются в metric name. 

*Спасибо!*

*У меня вопрос про* *alerting**. Мы сейчас используем* *Thanos**, он* *PromQL* *никак не расширяет, поэтому смело расставляем* *alerting* *в* *Prometheus* *и живем. А с расширением* *PromQL* *и с последующим* *alerting**, как у вас проблема решена? У вас отдельный* *alerting**?*

VictoriaMetrics поддерживает полностью весь PromQL, который стандартный в Prometheus. Можете писать стандартные запросы Prometheus’а, они будут работать. Или в дашборды Grafana, которые работают с Prometheus, заменить в их datasource для дашбордов только url. Только вместо Prometheus указать туда url VictoriaMetrics. И ваши дашборды будут работать, ничего не поломается. Это первое. 

И второе про alerting. Сейчас alerting никакого нет в VictoriaMetrics. Т. е. предполагается, что alerting будет происходить на Prometheus, которые пишут данные в VictoriaMetrics. Но в будущем мы собираемся создать с alerting сервис, который будет отдельно от Prometheus, отдельно от VictoriaMetrics, который будет совместим с alerting rules Prometheus'а. И он будет опрашивать внешний datasource. Он сможет опрашивать VictoriaMetrics, доставать оттуда данные и на основе их делать alerts, и отправлять их в alert manager.

*У* *VictoriaMetrics* *своя база данных или она является смесью синтактического сахара для запросов?*

У VictoriaMetrics собственная база данных, написанная с нуля. И она эффективнее намного, чем конкурирующие базы данных, т. е. она эффективнее по использованию ресурсов. Она требует меньше места на диске, т. е. данные сжимаются лучше, чем у конкурентов. Она требует меньше ресурсов процессора. И быстрее выполняет запросы. И также она требует меньше оперативной памяти для хранения большого количества метрик, time-series данных. 

*Еще вопрос. Вы сказали, что решили все проблемы* *PromQL**.*

Не все.

*Из тех, которые вы показали.*

Те, с которыми мы сталкивались.

*Я помню, там был* *JOIN**. Полноценный* *JOIN* *нормально работает с нескольких таблиц? Я смогу слинковать данные?*

В VictoriaMetrics данные можно лить с разных источников, в том числе с нескольких Prometheus, с нескольких Graphite, с любых источников. Эти данные все сливаются в одну таблицу фактически. И запросы можно встроить на всех данных этой таблицы с разных источников. Можно отправлять запросы в VictoriaMetrics и строить запросы по данным, собранным с разных Prometheus, хоть с тысячи, которые пишут в VictoriaMetrics.

*Т. е. ее можно использовать как кэш, как надстройку над текущими базами данными?*

Нет, не совсем. VictoriaMetrics в отличие от Thanos не опрашивает Prometheus, которые в нее пишут. VictoriaMetrics полностью автономная база. Она не знает ничего про все эти источники данных. Источники данных пишут данные в VictoriaMetrics. И потом VictoriaMetrics строит все запросы по всем данным, которые у нее хранятся. Она не лезет во внешние источники, чтобы забрать оттуда какие-то данные, в отличие от Thanos. Thanos, насколько я знаю, данные, которые записаны недавно, забирает из Prometheus, с которым он работает. И он подвержен проблемам обрыва сети или тормозов Prometheus, которые к нему пишут данные. VictoriaMetrics этим проблемам не подвержена. 

*Понятно, спасибо!*

*Спасибо за доклад! Вы сказали, что вы открываете исходные коды баз данных вашей* *VictoriaMetrics* *как* *single**-**node**, так и кластерной версии. Это будет прямо* *open* *source* *или все-таки будет какая-то лицензионная политика платной версии?*

Исходники будут открыты под Apache2 лицензии. Эта лицензия позволяет вам использовать исходники где хотите, главное оставлять копирайт наш, чтобы видеть, что вы использовали эти исходники. Т. е. вы можете в коммерческих продуктах использовать, но главное, вы должны указать, что в вашей коммерческой продукции использован код VictoriaMetrics.

*Спасибо! У вас на сайте есть сравнение с* *InfluxDB**, с* *Timescale**. Сравнение с колоночными базами проводили вы? Где-то можно посмотреть* *benchmarks**?*

Сравнение с колоночными базами не проводили. InfluxDB фактически тоже колоночная база данных. Мы с ней проводили сравнение. С ClickHouse не проводили сравнение. Но на сайте Altinity, это компания, которая оказывает консалтинговые услуги по ClickHouse, есть benchmarks. Они сравнивали производительность ClickHouse как time-series базу данных с Influx, по-моему. И с Timescale вроде тоже. 

Я сравнивал, какие у них результаты были с нашими результатами. И видел, что VictoriaMetrics выполняет легкие запросы. Там есть два типа запросов, которые быстро выполняются, т. е. за пару миллисекунд и тяжелые запросы, которые выполняются секунду и больше. 

Легкие запросы VictoriaMetrics выполняет намного быстрее, чем ClickHouse, а тяжелые запросы немного быстрее, чем ClickHouse, т. е. там примерно одинаково: кое-где медленнее, кое-где быстрее. 

*Какое при этом потребление ресурсов?*

Мы проводили benchmarks с учетом того, что потребление ресурсов 100 %. И ClickHouse, как мы знаем, старается тоже потреблять 100 % CPU при запросах.

*Понятно, спасибо!*

*Как у вас с резервированием, с кластеризацией?*

Репликации нет. Мы решили не делать репликацию на уровне кластера, на уровне VictoriaMetrics, потому что правильно сделать репликацию, чтобы она была надежной и гарантировала то, что она рекламирует, это очень сложно. Мы пока не придумали, как правильно это сделать. И полагаемся на реплицированный storage, на google cloud диски. Они рекламируются как диски, которые уже реплицируемые и на них данные не могут потеряться или испортиться из-за проблем оборудования, т. е. из-за выхода из строя дисков. Поэтому мы решили вот так пока делать. Может быть, в будущем добавим репликацию, но пока вот так. Т. е. желательно, если вы хотите использовать кластерную версию в production, хранить данные на надежных дисках, чтобы репликация уже происходила на уровне дисков, где вы храните данные. 

*У меня еще вопрос. У вас можно как-то реализовать функцию, когда, например, данные за вчера наложить на данные за сегодня?*

Да, это стандартная функция, которая есть в PromQL. Offset называется. Можно прописать offset 1d, и она вам вернет все значения для этой метрики за предыдущих день. Эти значения можно сминусовать, сплюсовать, т. е. делать любые операции с ними по сравнению с текущим значением.

*Есть какие-нибудь аналитические функции? Т. е., например, прочитать перцентиль этого дня, например, понедельник за последние три месяца?* 

Эта стандартная функциональность PromQL. Это то, что поддерживает Prometheus, перцентили там есть, можно считать за любой промежуток времени. Но ее нужно передавать квадратной скобкой в конце с указанием интервала, на котором считать перцентили, как rate. И там указывается в квадратных скобках. Например, она будет считать перцентиль за неделю.

*Спасибо!*

*Насколько будет открытой модель разработки? Вы сейчас заопенсертитесь. После этого возможны два варианта: либо делаем* *merge* *раз в полгода, и они там по 5* *GB**, а бывает, что вы просто приезжаете и там начинаете…*

Мы будем стараться вести разработку в открытую, кроме s… версии. Все остальные commit будут идти в открытую в public версии. Может быть, вопрос по другому перефразировать? Будем ли мы мержить pool request сторонние?

*Это вторая часть вопроса.*

Будем, но не все. Если мы будем видеть, что они полезны, то будем. Но будем стараться делать не так, как Brain Brazil, т. е. не будем говорить, что у нас есть data model и все. Если там хороший pool request, то будем мержить.  

